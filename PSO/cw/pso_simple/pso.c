// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI PARTICLE SWARM OPTIMISATION FOR GENETIC PROGRAMMING

// THIS FILE PERTAINS TOWARDS THE PSO ALGORITHM FOR OPTIMISING
// GENETIC PROGRAMMING PARAMETERS AND FITNESS EVALUATION

// SPECIFICALLY, THIS VERSION OF THE PSO IMPLEMENTATION
// AIMS TO PROVIDE AN UNDERSTANDING FOR HOW TO MITIGATE AN ISSUE
// RELATED TO THE DAILY DEMAND OF A LOGISTICS COMPANY

// THIS VERSION FOCUSSES ON THE SIMPLIFICATION OF THE CURRENT
// PSO IMPLEMENTATION - TO PROVIDE A POINT OF COMPARISON TO PROPERLY
// DISCERN THE BENEFITS OF EITHER OR

// NESTED INCLUDES

#include "pso_simple.h"

// INITIALISE THE PSO STATE BASE WITH IT'S DESIGNATED PARAMETERS SUCH AS 
// DIMENSIONS AND FITNESS TYPE, SWARM, BOUNDARIES, ETC 
int PSO_SIMPLE_INIT(PS STATE, int DIMENSIONS, PSO_FITNESS_EVAL FITNESS, void* USER_DATA)
{
    // CHECK IF WE HAVE VALID DIMENSIONS IN ACCORDANCE WITH 
    // THE TRAINING DATA
    if(!PSO_VALID_DIM(DIMENSIONS, PSO_MAX_DEM + 1))
    {
        PSO_ERROR_HANDLE(DIM, PSO_ERROR_DIM, 
            "INVALID DIMENSION COUNT: %d (MAX: %d)", 
            DIMENSIONS, PSO_MAX_DEM);
        return 1;
    }

    memset(STATE, 0, sizeof(PS));

    // NOW DEFINE ALL OF THE CORRESPONDENCE 
    // A LOT LESS TO DEFINE DUE TO THE BASELINE IMPL.
    STATE->DIMENSIONS = DIMENSIONS;
    STATE->FITNESS = FITNESS;
    STATE->USER_DATA = USER_DATA;
    STATE->SWARM.ITERATION = 0;
    STATE->SWARM.GBEST_FITNESS = DBL_MAX;
    
    PSO_HANDLE(NONE, PSO_ERROR_NONE,
        "\nPSO:\n" 
        "PARTICLES: %d\n" 
        "DIMENSIONS: %d\n"
        "INERTIA: %.5f (FIXED)\n"
        "COGNITIVE: %.5f (FIXED)\n"
        "SOCIAL: %.5f (FIXED)\n" 
        "MAX_ITER: %d\n",
        PSO_MAX_PARTICLES, DIMENSIONS,
        PSO_SIMPLE_INERTIA, PSO_SIMPLE_COG,
        PSO_SIMPLE_SOC, PSO_MAX_ITER);

    return 0;
}

void PSO_SIMPLE_BOUNDS(PS STATE, int DIMENSIONS, double LOWER, double UPPER)
{
    if(!PSO_VALID_DIM(DIMENSIONS, STATE->DIMENSIONS))
    {
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB,
            "DIMENSION %d OUT OF BOUNDS -> MAX DIMENSIONS: %d", DIMENSIONS, PSO_MAX_DEM);
        return;
    }

    STATE->BOUNDS[DIMENSIONS].LOWER = LOWER;
    STATE->BOUNDS[DIMENSIONS].UPPER = UPPER;

    #if PSO_DEBUG
    PSO_HANDLE(NONE, PSO_ERROR_NONE, 
        "DIMENSIONS SET WITH BOUNDS: [L]: %.2f -> [R]: %.2f\n", 
        LOWER, UPPER);
    #endif
}

// INITIALISE A SINGLE PARTICLE WITH A RANDOM POSITION AND VELOCITY
/// WITHIN THE SWARM - PRESUPPOSES A PERSONAL BEST AFTER THE FACT
static void PSO_SIMPLE_PARTICLE(PARTICLE P, const BOUNDS B, int DIMENSIONS)
{
    // ITERATE THROUGH EACH RESPECTIVE POSSIBLE RANGE FOR 
    // WHICH A PARTICLE WITHIN THE SWARM CAN EXIST
    //
    // DEFINE THE POSITION AND VELOCITY FOR SUCH
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        double PARTCILE_RANGE = B[INDEX].UPPER - B[INDEX].LOWER;

        P->POSITION[INDEX] = B[INDEX].LOWER + (PSO_RAND() * PARTCILE_RANGE);
        P->VELOCITY[INDEX] = (PSO_RAND() * PARTCILE_RANGE * 2.0) - PARTCILE_RANGE;
        P->PBEST[INDEX] = P->POSITION[INDEX];
    } 
}

// CREATE A RANDOM SEED FOR THE ALL ENCOMPASSING SWARM
// RATHER THAN BEING DELEGATED ON THE BASIS OF A LINEAR REPRESENTATION OF 
// PARTICLES, THIS SEED WILL BE RANDOMISED IN ACCORDANCE WITH THE TEST DATA
static void PSO_SIMPLE_SWARM(PS STATE)
{   
    PSO_SEED();

    // ITERATE THROUGH ALL OF THE CORRESPONDENCE OF THE AMOUNT
    // OF PARTICLES WITHIN THE SWARM
    // ITERATE THROUGH THE MAX PARTICLES AND ASSIGN THEM
    for(int INDEX = 0; INDEX < PSO_MAX_PARTICLES; INDEX++)
    {
        PARTICLE P = &STATE->SWARM.PARTICLES[INDEX];
        PSO_SIMPLE_PARTICLE(P, STATE->BOUNDS, STATE->DIMENSIONS);

        P->CURRENT_FITNESS = STATE->FITNESS(P->POSITION, STATE->DIMENSIONS, STATE->USER_DATA);
        P->PBEST_FITNESS = P->CURRENT_FITNESS;
        P->STAGNATE = 0;

        // NOW PROPERLY ASSIGN THE CURRENT FITNESS TO THE GLOBAL BEST
        // THIS WAY, THE SWARM IS ABLE TO PROPERLY DETERMINE IT'S PROPER SIZE
        if(P->CURRENT_FITNESS < STATE->SWARM.GBEST_FITNESS)
        {
            STATE->SWARM.GBEST_FITNESS = P->CURRENT_FITNESS;
            for(int DIMENSIONS = 0; DIMENSIONS < STATE->DIMENSIONS; DIMENSIONS++)
            {
                STATE->SWARM.GBEST[DIMENSIONS] = P->POSITION[DIMENSIONS];
            }
        }
    }
}

// UPDATES THE INERTIA VELOCITY OF THE SWARM
// BASD ON THE FIXED INERTIA AND COMPONENT PARAMETERS
static void PSO_UPDATE_INERTIA(PARTICLE P, const double* GBEST, int DIMENSIONS)
{
    double COGNITIVE = 0.0;
    double SOCIAL = 0.0;

    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        double COG_RAND = PSO_RAND();
        double SOC_RAND = PSO_RAND();

        // NOW UPDATE THE INERTIA VELOCITY BASSD ON THE FORMULA 
        // WITH DUE REGARD FOR FIXED COEFFICIENTS 
        
        COGNITIVE = PSO_SIMPLE_COG * COG_RAND * (P->PBEST[INDEX] - P->POSITION[INDEX]);
        SOCIAL = PSO_SIMPLE_SOC * SOC_RAND * (GBEST[INDEX] - P->POSITION[INDEX]);

        // APPLY THE FIXED COEFFICIENTS TO THE VELOCITY BASED ON COMPONENTS
        P->VELOCITY[INDEX] = (PSO_SIMPLE_INERTIA * P->VELOCITY[INDEX]) + COGNITIVE + SOCIAL;
    }

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "PSO INERTIA UPDATED: VELOCITY: %.6f", P->VELOCITY[0]);
}

// NOW DO THE SAME BUT FOR POSITION
// THE DIFFERENCE HERE BEING IS THAT WE WANT
// TO ENSURE PROPER CLAMPING OF POSITIONS IN ACCORDANCE WITH THE BOUNDS
static void PSO_UPDATE_POS(PARTICLE P, const BOUNDS B, int DIMENSIONS)
{
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        P->POSITION[INDEX] += P->VELOCITY[INDEX];

        // SET BOUNDS PROPERLY
        // DETERMINE THE VELOCITY FOR EACH TO LEVERAGE 
        // A BIAS FOR HANDLING THE WEIGHTS
        if(P->POSITION[INDEX] < B[INDEX].LOWER)
        {
            P->POSITION[INDEX] = B[INDEX].LOWER;
            P->VELOCITY[INDEX] *= PSO_INER_DAMP;
        }
        else if(P->POSITION[INDEX] > B[INDEX].UPPER)
        {
            P->POSITION[INDEX] = B[INDEX].UPPER;
            P->VELOCITY[INDEX] *= PSO_INER_DAMP;
        }
    }
}

// UPDATE THE PERSONAL BEST BASED ON THE CURRENT FITNESS
static void PSO_UPDATE_PBEST(PARTICLE P, int DIMENSIONS)
{
    if(P->CURRENT_FITNESS < P->PBEST_FITNESS)
    {
        P->PBEST_FITNESS = P->CURRENT_FITNESS;

        // ITERATE THROUGH ALL OF THE DIMENSIONS
        // GIVEN TO THE SWARM
        for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
        {
            P->PBEST[INDEX] = P->POSITION[INDEX];
        }

        P->STAGNATE = 0;
    }
    else
    {
        P->STAGNATE++;
    }
}

// AND DO THE SAME FOR THE GLOBAL BEST
// FOR THIS, WE WANT TO BE ABLE TO DETERMINE THE CONVERGENCE RATE
// FOR THE CURRENT SWARM ITERATION
static void PSO_UPDATE_GBEST(PS STATE)
{
    for(int INDEX = 0; INDEX < PSO_MAX_PARTICLES; INDEX++)
    {
        PARTICLE P = &STATE->SWARM.PARTICLES[INDEX];

        // DO WE ACTUALLY HAVE A NEW BEST FITNESS?
        if(P->PBEST_FITNESS < STATE->SWARM.GBEST_FITNESS)
        {
            STATE->SWARM.GBEST_FITNESS = P->PBEST_FITNESS;
            STATE->STATS.CONVERGENCE_ITER = STATE->SWARM.ITERATION;

            PSO_HANDLE(NONE, PSO_ERROR_NONE, 
                "NEW GLOBAL BEST FITNESS: %.2f AT ITERATION %d -> ORIGINAL FITNESS: %2.f", 
                P->PBEST_FITNESS, STATE->SWARM.ITERATION, P->CURRENT_FITNESS);

            // BASED ON THE DIMENSIONS OF THE CURRENT SWARM, APPLY THE BEST TO SUCH
            for(int ITERATOR = 0; ITERATOR < STATE->DIMENSIONS; ITERATOR++)
            {
                STATE->SWARM.GBEST[ITERATOR] = P->PBEST[ITERATOR];
            }
        }
    }
}

// OPTIMISE THE ALGORITHM IN ACCORDANCE WITH THE EVALUATION
// OF THE FITNESS OF THE CURRENT INERTIA
void PSO_SIMPLE_OPTIMSISE(PS STATE)
{
    PSO_SIMPLE_SWARM(STATE);

    // CREATE THE INITIAL BASIS FOR THE FITNESS EVALUATION
    // THE FOLLOWING WILL CREATE A PARTICLE TO ADD TO THE SWARM
    // BASED ON THE MAX, APPLY THE CURRENT FITNESS TO THE GLOBAL BEST 
    // AND UPDATE ALL OF THE CORRESPONDENCE

    STATE->STATS.INIT_FITNESS = STATE->SWARM.GBEST_FITNESS;

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "INITAL FITNESS FOR SWARM: %.6f\n", STATE->SWARM.GBEST_FITNESS);

    // NOW WE CAN ITERATE THROUGH EACH INSTANCE 
    // OF THE ALGORITHM IN ACCORDANCE WITH THE MAX AMOUNT
    // OF ITERATIONS

    for(int INDEX = 0; INDEX < PSO_MAX_ITER; INDEX++)
    {
        STATE->SWARM.ITERATION = INDEX;

        for(int PARTICLE_ITER = 0; PARTICLE_ITER < PSO_MAX_PARTICLES; PARTICLE_ITER++)
        {
            PARTICLE P = &STATE->SWARM.PARTICLES[PARTICLE_ITER];

            // UPDATE ALL OF THE CORRESPONDENCE WITH DUE REGARD
            // FOR THE FIXED COEFFICIENTS
            PSO_UPDATE_INERTIA(P, STATE->SWARM.GBEST, STATE->DIMENSIONS);
            PSO_UPDATE_POS(P, STATE->BOUNDS, STATE->DIMENSIONS);

            P->CURRENT_FITNESS = STATE->FITNESS(P->POSITION, STATE->DIMENSIONS, STATE->USER_DATA);
            PSO_UPDATE_PBEST(P, STATE->DIMENSIONS);
        }

        PSO_UPDATE_GBEST(STATE);
    }

    STATE->STATS.FINAL_FITNESS = STATE->SWARM.GBEST_FITNESS;
    STATE->STATS.IMPROVEMENT_RATE = (STATE->STATS.INIT_FITNESS - STATE->STATS.FINAL_FITNESS) /
                                    STATE->STATS.INIT_FITNESS * 100.0;

    // NOW WE DETERMINE THE DIFFERENCE BETWEEN THE INITIAL BEST FITNESS
    // AND THE FINAL
    PSO_HANDLE(NONE, PSO_ERROR_NONE, "\n"
        "\nFINAL FITNESS: %.6f\n" 
        "IMPROVEMENT RATE: %.2f%% (FROM %.6f to %.6f)\n"
        "BEST FOUND AT ITERATION: %d\n\n", 
        STATE->STATS.FINAL_FITNESS, STATE->STATS.IMPROVEMENT_RATE,
        STATE->STATS.INIT_FITNESS, STATE->STATS.FINAL_FITNESS, (int)STATE->STATS.CONVERGENCE_ITER);
}
