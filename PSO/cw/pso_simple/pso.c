// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI PARTICLE SWARM OPTIMISATION FOR GENETIC PROGRAMMING

// THIS FILE PERTAINS TOWARDS THE PSO ALGORITHM FOR OPTIMISING
// GENETIC PROGRAMMING PARAMETERS AND FITNESS EVALUATION

// SPECIFICALLY, THIS VERSION OF THE PSO IMPLEMENTATION
// AIMS TO PROVIDE AN UNDERSTANDING FOR HOW TO MITIGATE AN ISSUE
// RELATED TO THE DAILY DEMAND OF A LOGISTICS COMPANY

// THIS VERSION FOCUSSES ON THE SIMPLIFICATION OF THE CURRENT
// PSO IMPLEMENTATION - TO PROVIDE A POINT OF COMPARISON TO PROPERLY
// DISCERN THE BENEFITS OF EITHER OR

// NESTED INCLUDES

#include "pso_simple.h"

// INITIALISE THE PSO STATE BASE WITH IT'S DESIGNATED PARAMETERS SUCH AS 
// DIMENSIONS AND FITNESS TYPE, SWARM, BOUNDARIES, ETC 
int PSO_SIMPLE_INIT(PS STATE, int DIMENSIONS)
{
    // CHECK IF WE HAVE VALID DIMENSIONS IN ACCORDANCE WITH 
    // THE TRAINING DATA
    if(!PSO_VALID_DIM(DIMENSIONS, PSO_MAX_DEM + 1))
    {
        PSO_ERROR_HANDLE(DIM, PSO_ERROR_DIM, 
            "INVALID DIMENSION COUNT: %d (MAX: %d)", 
            DIMENSIONS, PSO_MAX_DEM);
        return 1;
    }

    memset(STATE, 0, sizeof(PS));

    // NOW DEFINE ALL OF THE CORRESPONDENCE 
    // A LOT LESS TO DEFINE DUE TO THE BASELINE IMPL.
    STATE->DIMENSIONS = DIMENSIONS;
    STATE->SWARM.ITERATION = 0;
    STATE->SWARM.GBEST_FITNESS = DBL_MAX;
    
    PSO_HANDLE(NONE, PSO_ERROR_NONE,
        "\nPSO:\n" 
        "PARTICLES: %d\n" 
        "DIMENSIONS: %d\n"
        "INERTIA: %.5f (FIXED)\n"
        "COGNITIVE: %.5f (FIXED)\n"
        "SOCIAL: %.5f (FIXED)\n" 
        "MAX_ITER: %d\n",
        PSO_MAX_PARTICLES, DIMENSIONS,
        PSO_SIMPLE_INERTIA, PSO_SIMPLE_COG,
        PSO_SIMPLE_SOC, PSO_MAX_ITER);

    return 0;
}

void PSO_SIMPLE_BOUNDS(PS STATE, int DIMENSIONS, double LOWER, double UPPER)
{
    if(!PSO_VALID_DIM(DIMENSIONS, STATE->DIMENSIONS))
    {
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB,
            "DIMENSION %d OUT OF BOUNDS -> MAX DIMENSIONS: %d", DIMENSIONS, PSO_MAX_DEM);
        return;
    }

    STATE->BOUNDS[DIMENSIONS].LOWER = LOWER;
    STATE->BOUNDS[DIMENSIONS].UPPER = UPPER;

    #if PSO_DEBUG
    PSO_HANDLE(NONE, PSO_ERROR_NONE, 
        "DIMENSIONS SET WITH BOUNDS: [L]: %.2f -> [R]: %.2f\n", 
        LOWER, UPPER);
    #endif
}

// INITIALISE A SINGLE PARTICLE WITH A RANDOM POSITION AND VELOCITY
/// WITHIN THE SWARM - PRESUPPOSES A PERSONAL BEST AFTER THE FACT
static void PSO_SIMPLE_PARTICLE(PARTICLE P, const BOUNDS B, int DIMENSIONS)
{
    // ITERATE THROUGH EACH RESPECTIVE POSSIBLE RANGE FOR 
    // WHICH A PARTICLE WITHIN THE SWARM CAN EXIST
    //
    // DEFINE THE POSITION AND VELOCITY FOR SUCH
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        double PARTCILE_RANGE = B[INDEX].UPPER - B[INDEX].LOWER;

        P->POSITION[INDEX] = B[INDEX].LOWER + (PSO_RAND() * PARTCILE_RANGE);
        P->VELOCITY[INDEX] = (PSO_RAND() * PARTCILE_RANGE * 2.0) - PARTCILE_RANGE;
        P->PBEST[INDEX] = P->POSITION[INDEX];
    } 

    P->PBEST_FITNESS = DBL_MAX;
    P->CURRENT_FITNESS = DBL_MAX;
    P->STAGNATE = 0;
}

// CREATE A RANDOM SEED FOR THE ALL ENCOMPASSING SWARM
// RATHER THAN BEING DELEGATED ON THE BASIS OF A LINEAR REPRESENTATION OF 
// PARTICLES, THIS SEED WILL BE RANDOMISED IN ACCORDANCE WITH THE TEST DATA
static void PSO_SIMPLE_SWARM(PS STATE)
{   
    PSO_SEED();

    // ITERATE THROUGH ALL OF THE CORRESPONDENCE OF THE AMOUNT
    // OF PARTICLES WITHIN THE SWARM
    // ITERATE THROUGH THE MAX PARTICLES AND ASSIGN THEM
    for(int INDEX = 0; INDEX < PSO_MAX_PARTICLES; INDEX++)
    {
        PSO_INIT_PARTICLE(&STATE->SWARM.PARTICLES[INDEX], STATE->BOUNDS, STATE->DIMENSIONS);
    }
}
