// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI PARTICLE SWARM OPTIMISATION FOR GENETIC PROGRAMMING

// THIS FILE PERTAINS TOWARDS THE PSO ALGORITHM FOR OPTIMISING
// GENETIC PROGRAMMING PARAMETERS AND FITNESS EVALUATION

// SPECIFICALLY, THIS VERSION OF THE PSO IMPLEMENTATION
// AIMS TO PROVIDE AN UNDERSTANDING FOR HOW TO MITIGATE AN ISSUE
// RELATED TO THE DAILY DEMAND OF A LOGISTICS COMPANY

// LEVERAGING ADAPTIVE INERTIA CONTROL FOR GENERATING
// A BEST FIT SOLUTION BASED CURRENT FITNESS - MADE POSSIBLE BY DYNAMICALLY
// ADJUSTING THE WEIGHT OF PARTICLES BASED ON THEIR CHARACTERISTICS 
// DURING THE LIFETIME OF THE ALGORITHM

// NESTED INCLUDES

#include "pso.h"

// INITIALISE THE PSO STATE BASE WITH IT'S DESIGNATED PARAMETERS SUCH AS 
// DIMENSIONS AND FITNESS TYPE, SWARM, BOUNDARIES, ETC 
int PSO_INIT(PSO_STATE* STATE, int DIMENSIONS)
{
    if(STATE == NULL) { perror(STATE); }

    // CHECK IF WE HAVE VALID DIMENSIONS IN ACCORDANCE WITH 
    // THE TRAINING DATA
    if(!PSO_VALID_DIM(DIMENSIONS, PSO_MAX_DEM + 1))
    {
        PSO_ERROR_HANDLE(DIM, PSO_ERROR_DIM, 
            "INVALID DIMENSION COUNT: %d (MAX: %d)", 
            DIMENSIONS, PSO_MAX_DEM);
        return 1;
    }

    memset(STATE, 0, sizeof(PSO_STATE));

    // NOW DEFINE ALL OF THE CORRESPONDENCE 
    STATE->DIMENSIONS = DIMENSIONS;
    STATE->CONV_THRESHOLD = DBL_MAX;
    STATE->SWARM.PARTICLES->COUNT = PSO_MAX_PARTICLES;
    STATE->SWARM.ITERATION = 0;
    STATE->SWARM.GBEST_FITNESS = DBL_MAX;
    STATE->SWARM.CONVERGED = 0;
    STATE->SWARM.DIVERSITY = 1.0;
    STATE->SWARM.STAGNATE = 0;
    
    // DEFINE ALL OF THE ADAPTIVE PARAMETERS
    STATE->CURRENT_INERTIA = PSO_MAX_INERTIA;
    STATE->CURRENT_COG = PSO_COG_INIT;
    STATE->CURRENT_SOC = PSO_SOC_INIT;

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "\nPSO:\n PARTICLES: %d\n DIMENSIONS: %d\n MAX_ITER: %d\n", 
        PSO_MAX_PARTICLES, DIMENSIONS, PSO_MAX_ITER);

    return 0;
}

// SET CUSTOM BOUNDS FOR A SPECIFIC DIMENSION
void PSO_SET_BOUNDS(PSO_STATE* STATE, int DIMENSION, double LOWER, double UPPER)
{
    if(!PSO_VALID_DIM(DIMENSION, STATE->DIMENSIONS))
    {
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB, 
            "DIMENSION %d OUT OF BOUNDS, MAX DIMENSION VALUE: %d", 
            DIMENSION, PSO_MAX_DEM);

        return;
    }

    // ASSIGN THE CORRESPONDING BOUNDS TO THE STATE 
    STATE->BOUNDS[DIMENSION].LOWER = LOWER;
    STATE->BOUNDS[DIMENSION].UPPER = UPPER;
}

// INITIALISE A SINGLE PARTICLE WITH A RANDOM POSITION AND VELOCITY
/// WITHIN THE SWARM - PRESUPPOSES A PERSONAL BEST AFTER THE FACT
static void PSO_INIT_PARTICLE(PSO_PARTICLE* PARTICLE, const PSO_BOUND* BOUNDS, int DIMENSIONS)
{
    // ITERATE THROUGH EACH RESPECTIVE POSSIBLE RANGE FOR 
    // WHICH A PARTICLE WITHIN THE SWARM CAN EXIST
    //
    // DEFINE THE POSITION AND VELOCITY FOR SUCH
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        double PARTCILE_RANGE = BOUNDS[INDEX].UPPER - BOUNDS[INDEX].LOWER;

        PARTICLE->POSITION[INDEX] = BOUNDS[INDEX].LOWER + (PSO_RAND() * PARTCILE_RANGE);
        PARTICLE->VELOCITY[INDEX] = (PSO_RAND() * PARTCILE_RANGE * 2.0) - PARTCILE_RANGE;
        PARTICLE->PBEST[INDEX] = PARTICLE->POSITION[INDEX];
    } 

    PARTICLE->PBEST_FITNESS = DBL_MAX;
    PARTICLE->CURRENT_FITNESS = DBL_MAX;
    PARTICLE->STAGNATE = 0;
}

// CREATE A RANDOM SEED FOR THE ALL ENCOMPASSING SWARM
// RATHER THAN BEING DELEGATED ON THE BASIS OF A LINEAR REPRESENTATION OF 
// PARTICLES, THIS SEED WILL BE RANDOMISED IN ACCORDANCE WITH THE TEST DATA
//
// THE TEST DATA OF WHICH WILL BE THE DETERMINANT FOR HOW WELL THE SWARM PERFORMS
// IN ACCORDANCE WITH THE ADAPTIVE MEASURES
static void PSO_INIT_SWARM(PSO_STATE* STATE)
{
    PSO_SEED();

    // ITERATE THROUGH THE MAX PARTICLES AND ASSIGN THEM
    for(int INDEX = 0; INDEX < PSO_MAX_PARTICLES; INDEX++)
    {
        PSO_INIT_PARTICLE(&STATE->SWARM.PARTICLES[INDEX], STATE->BOUNDS, STATE->DIMENSIONS);
    }
}

// DEFINE THE BASIS BY WHICH WE ARE ABLE TO DETERMINE THE
// CURRENT DEMAND ON BEHALF OF THE LOGISTICS COMPANY OUTLINED IN THE BRIEF
//
// PRESUPPOSES THE CONTEXT OF THE CURRENT BIAS AS PER EACH PREDICTION
static double PSO_PREDICT(const double* PARAMS, const double* INDICATIONS)
{
    double PREDICTION = PARAMS[0];          // THE PARAMS ENCOMPASSING EACH PREDICTION AGAINST THE BIAS (aN)

    for(int INDEX = 0; INDEX < PSO_MAX_IND; INDEX++)
    {
        PREDICTION += PARAMS[INDEX + 1] * INDICATIONS[INDEX];
    }

    if(PREDICTION >= PSO_MAX_IND)
    {
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB, 
            "WARNING: PREDICTION OF INDEX: %.2f HAS EXCEEDED MAX VALUE: %d\n",
            PREDICTION, PSO_MAX_IND);
    }

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "PREDICTION: %2.f", PREDICTION);
    return PREDICTION;
}

// DEFINE THE BASIS BY WHICH WE ARE ABLE TO DETERMINE THE EFFECTIVENESS 
// OF THE DEMAND AND IT'S FITNESS
//
// THIS WILL BE UNDER THE PRETENSE OF USING MAE (THE REPRESENTATION OF AVERAGE ABSOLUTE ERROR)
//
// IN THEORY, THIS SHOULD ALLOW US TO GARNER A LOWER MARGIN OF ERROR
// TO HELP WITH CREATING LARGER PREDICTIONS TO MITIGATE OVERHEAD
double PSO_DEMAND_FITNESS(const double* PARAMS, const PSO_DATASET* DATASET)
{
    double PREDICTION = 0;
    double ERROR = 0;
    double TOTAL_ERROR = 0.0;
    double MAE = 0;

    // DO WE HAVE ANY VALID DATA TO BEGIN WITH?
    if(DATASET->SIZE == 0) 
    { 
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB, "DATASET DOESN'T HAVE ANY DATA: %d\n", DATASET->SIZE); 
    }

    // GARNER THE TOTAL ERROR ABSOLUTE VALUE
    // FROM THE PREDICITION IN THE DEMAND SET
    for(int INDEX = 0; INDEX < DATASET->SIZE; INDEX++)
    {
        PREDICTION = PSO_PREDICT(PARAMS, DATASET->DATA[INDEX].INDICTIONS);
        ERROR = fabs(PREDICTION - DATASET->DATA[INDEX].DEMANDS);
        
        // ASSIGN THE ABOVE TO THE TOTAL ERROR COST
        TOTAL_ERROR += ERROR;
    } 

    // ASSIGN THE AVERAGE ABSOLUTE AGAINST THE SIZE OF THE DATASET
    // THIS WILL DETERMINE THE EFFECTIVENESS OF THE SAVED COST
    MAE = TOTAL_ERROR / DATASET->SIZE;

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "AVERAGE ABSOLUTE ERROR: %d FOR PREDICTION: %d\n", MAE, PREDICTION);
    return MAE;
}
