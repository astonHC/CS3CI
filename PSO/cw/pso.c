// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI PARTICLE SWARM OPTIMISATION FOR GENETIC PROGRAMMING

// THIS FILE PERTAINS TOWARDS THE PSO ALGORITHM FOR OPTIMISING
// GENETIC PROGRAMMING PARAMETERS AND FITNESS EVALUATION

// SPECIFICALLY, THIS VERSION OF THE PSO IMPLEMENTATION
// AIMS TO PROVIDE AN UNDERSTANDING FOR HOW TO MITIGATE AN ISSUE
// RELATED TO THE DAILY DEMAND OF A LOGISTICS COMPANY

// LEVERAGING ADAPTIVE INERTIA CONTROL FOR GENERATING
// A BEST FIT SOLUTION BASED CURRENT FITNESS - MADE POSSIBLE BY DYNAMICALLY
// ADJUSTING THE WEIGHT OF PARTICLES BASED ON THEIR CHARACTERISTICS 
// DURING THE LIFETIME OF THE ALGORITHM

// NESTED INCLUDES

#include "pso.h"

// INITIALISE THE PSO STATE BASE WITH IT'S DESIGNATED PARAMETERS SUCH AS 
// DIMENSIONS AND FITNESS TYPE, SWARM, BOUNDARIES, ETC 
int PSO_INIT(PSO_STATE* STATE, int DIMENSIONS)
{
    if(STATE == NULL) { perror(STATE); }

    // CHECK IF WE HAVE VALID DIMENSIONS IN ACCORDANCE WITH 
    // THE TRAINING DATA
    if(!PSO_VALID_DIM(DIMENSIONS, PSO_MAX_DEM + 1))
    {
        PSO_ERROR_HANDLE(DIM, PSO_ERROR_DIM, 
            "INVALID DIMENSION COUNT: %d (MAX: %d)", 
            DIMENSIONS, PSO_MAX_DEM);
        return 1;
    }

    memset(STATE, 0, sizeof(PSO_STATE));

    // NOW DEFINE ALL OF THE CORRESPONDENCE 
    STATE->DIMENSIONS = DIMENSIONS;
    STATE->CONV_THRESHOLD = DBL_MAX;
    STATE->SWARM.PARTICLES->COUNT = PSO_MAX_PARTICLES;
    STATE->SWARM.ITERATION = 0;
    STATE->SWARM.GBEST_FITNESS = DBL_MAX;
    STATE->SWARM.CONVERGED = 0;
    STATE->SWARM.DIVERSITY = 1.0;
    STATE->SWARM.STAGNATE = 0;
    
    // DEFINE ALL OF THE ADAPTIVE PARAMETERS
    STATE->CURRENT_INERTIA = PSO_MAX_INERTIA;
    STATE->CURRENT_COG = PSO_COG_INIT;
    STATE->CURRENT_SOC = PSO_SOC_INIT;

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "\nPSO:\n PARTICLES: %d\n DIMENSIONS: %d\n MAX_ITER: %d\n", 
        PSO_MAX_PARTICLES, DIMENSIONS, PSO_MAX_ITER);

    return 0;
}

// SET CUSTOM BOUNDS FOR A SPECIFIC DIMENSION
void PSO_SET_BOUNDS(PSO_STATE* STATE, int DIMENSION, double LOWER, double UPPER)
{
    if(!PSO_VALID_DIM(DIMENSION, STATE->DIMENSIONS))
    {
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB, 
            "DIMENSION %d OUT OF BOUNDS, MAX DIMENSION VALUE: %d", 
            DIMENSION, PSO_MAX_DEM);

        return;
    }

    // ASSIGN THE CORRESPONDING BOUNDS TO THE STATE 
    STATE->BOUNDS[DIMENSION].LOWER = LOWER;
    STATE->BOUNDS[DIMENSION].UPPER = UPPER;
}

// INITIALISE A SINGLE PARTICLE WITH A RANDOM POSITION AND VELOCITY
/// WITHIN THE SWARM - PRESUPPOSES A PERSONAL BEST AFTER THE FACT
static void PSO_INIT_PARTICLE(PSO_PARTICLE* PARTICLE, const PSO_BOUND* BOUNDS, int DIMENSIONS)
{
    // ITERATE THROUGH EACH RESPECTIVE POSSIBLE RANGE FOR 
    // WHICH A PARTICLE WITHIN THE SWARM CAN EXIST
    //
    // DEFINE THE POSITION AND VELOCITY FOR SUCH
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        double PARTCILE_RANGE = BOUNDS[INDEX].UPPER - BOUNDS[INDEX].LOWER;

        PARTICLE->POSITION[INDEX] = BOUNDS[INDEX].LOWER + (PSO_RAND() * PARTCILE_RANGE);
        PARTICLE->VELOCITY[INDEX] = (PSO_RAND() * PARTCILE_RANGE * 2.0) - PARTCILE_RANGE;
        PARTICLE->PBEST[INDEX] = PARTICLE->POSITION[INDEX];
    } 

    PARTICLE->PBEST_FITNESS = DBL_MAX;
    PARTICLE->CURRENT_FITNESS = DBL_MAX;
    PARTICLE->STAGNATE = 0;
}

// CREATE A RANDOM SEED FOR THE ALL ENCOMPASSING SWARM
// RATHER THAN BEING DELEGATED ON THE BASIS OF A LINEAR REPRESENTATION OF 
// PARTICLES, THIS SEED WILL BE RANDOMISED IN ACCORDANCE WITH THE TEST DATA
//
// THE TEST DATA OF WHICH WILL BE THE DETERMINANT FOR HOW WELL THE SWARM PERFORMS
// IN ACCORDANCE WITH THE ADAPTIVE MEASURES
static void PSO_INIT_SWARM(PSO_STATE* STATE)
{
    PSO_SEED();

    // ITERATE THROUGH THE MAX PARTICLES AND ASSIGN THEM
    for(int INDEX = 0; INDEX < PSO_MAX_PARTICLES; INDEX++)
    {
        PSO_INIT_PARTICLE(&STATE->SWARM.PARTICLES[INDEX], STATE->BOUNDS, STATE->DIMENSIONS);
    }
}