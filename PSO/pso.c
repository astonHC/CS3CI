// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI PARTICLE SWARM OPTIMISATION FOR GENETIC PROGRAMMING

// THIS FILE PERTAINS TOWARDS THE IMEPLEMENTATION AND MODULARISATION OF THE PSO
// THE FOLLOWING WILL PRESUPPOSE A CURATION OF PARTICLES TO ACT AS A SEPARATED
// COLLECTION OF SOLUTIONS TO CREATE A MORE EFFICIENT SEARCH SPACE FOR A POTENTIAL SOLUTION
//
// SUPPOSE THE BEST COMPARISON COULD BE THAT OF MEMORY ALLOCATION
// WHEREBY LITTLE CHUNKS ARE CREATED TO DELEGATE SPACE FOR ALLOCATION AND DISCERNMENT 
// FOR SOLUTION SPACE

// NESTED INCLUDES

#include "pso.h"

// INITIALISE THE PSO STATE BASE WITH IT'S DESIGNATED PARAMETERS SUCH AS 
// DIMENSIONS AND FITNESS TYPE, SWARM, BOUNDARIES, ETC 
int PSO_INIT(PSO* PSO_STATE, int DIMENSIONS, PSO_FITNESS_TYPE TYPE)
{
    if(PSO_STATE == NULL) { PSO_MEM_ERROR(PSO_STATE); }

    // DO WE HAVE VALID DIMENSIONS FOR THE SEARCH SPACE 
    if(!PSO_VALID_DIMENSIONS(DIMENSIONS, PSO_MAX_DIMENSIONS + 1)) goto PSO_ERROR_DIM;

    PSO_STATE->DIMENSIONS = DIMENSIONS;
    PSO_STATE->FITNESS = TYPE;
    PSO_STATE->CONV_THRESHOLD = INT_MAX;
    PSO_STATE->SWARM.PARTICLE_PARAMS.COUNT = PSO_MAX_PARTICLES;
    PSO_STATE->SWARM.PARTICLE_PARAMS.CONVERGENCE = 0;
    PSO_STATE->SWARM.PARTICLE_PARAMS.ITERATION = 0;
    PSO_STATE->SWARM.GLOBAL_FITNESS = INT_MAX;

    // INITIALISE THE DEFAULT BOUNDS
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        PSO_SET_BOUNDS(PSO_STATE, INDEX, -100.0, 100.0);
    }

    // INITIALISE THE DEFAULT POSITIONING FOR THE GP
    for(int INDEX = 0; INDEX < DIMENSIONS; INDEX++)
    {
        PSO_STATE->SWARM.GLOBAL_POS[INDEX] = 0.0;
    }

    PSO_HANDLE(NONE, PSO_ERROR_NONE, "\nPSO:\n PARTICLES: %d\n DIMENSIONS: %d\n FITNESS: %s\n MAX_ITER: %d\n", 
        PSO_MAX_PARTICLES, DIMENSIONS, PSO_FITNESS_NAME(TYPE), PSO_MAX_ITERATIONS);

    return 0;

    PSO_ERROR_DIM:
        PSO_ERROR_HANDLE(DIMENSIONS, PSO_ERROR_DIM, 
            "INVALID DIMENSION COUNT: %d (MAX: %d)\n", 
            DIMENSIONS, PSO_MAX_DIMENSIONS);
        return 1;
}

// SET CUSTOM BOUNDS FOR A SPECIFIC DIMENSION
void PSO_SET_BOUNDS(PSO* PSO_STATE, int DIMENSION, double LOWER, double UPPER)
{
    if(!PSO_VALID_DIMENSIONS(DIMENSION, PSO_STATE->DIMENSIONS))
    {
        PSO_ERROR_HANDLE(OOB, PSO_ERROR_OOB, "DIMENSION %d OUT OF BOUNDS", DIMENSION);
        return;
    }

    PSO_STATE->BOUNDS[DIMENSION].LOWER = LOWER;
    PSO_STATE->BOUNDS[DIMENSION].UPPER = UPPER;
}

// EXTRACT A RANDOM VALUE FROM THE LOWER AND UPPER BOUNDS
// DONE BY CASTING A NEW RANDOM FROM THE RANGE BASED ON THE EXPONENT
static double PSO_RAND(double LOWER, double UPPER)
{
    return LOWER + ((double)rand() / RAND_MAX) * (UPPER - LOWER);
}

// INITIALISE A SINGLE PARTICLE WITH A RANDOM POSITION AND VELOCITY
/// WITHIN THE SWARM - PRESUPPOSES A PERSONAL BEST AFTER THE FACT
static void PSO_INIT_PARTICLE(PSO* PSO_STATE, PSO_PARTICLE* PARTICLE)
{
    for(int DIMENSIONS = 0; DIMENSIONS < PSO_STATE->DIMENSIONS; DIMENSIONS++)
    {
        // ACCESS A RANDOM POSITION WITHIN THE BOUNDS
        PARTICLE->POSITION[DIMENSIONS] = PSO_RAND
        (
            PSO_STATE->BOUNDS[DIMENSIONS].LOWER,
            PSO_STATE->BOUNDS[DIMENSIONS].UPPER
        );

        double RANGE = PSO_STATE->BOUNDS[DIMENSIONS].UPPER - PSO_STATE->BOUNDS[DIMENSIONS].LOWER;
        PARTICLE->VELOCITY[DIMENSIONS] = PSO_RAND(-RANGE * PSO_RANGE_EXPO, RANGE * PSO_RANGE_EXPO);
        PARTICLE->BEST_POS[DIMENSIONS] = PARTICLE->POSITION[DIMENSIONS];
    }

    PARTICLE->BEST_FITNESS = INT_MAX;
    PARTICLE->CURRENT_FITNESS = INT_MAX;
    PARTICLE->STAGNATE = 0;
}

// CREATE THE INITIAL SWARM FOR ALL OF THE PARTICLES
// ITERATES AGAINST THE MAX PARTICLES WITHIN THE SWARM
static void PSO_INIT_SWARM(PSO* PSO_STATE)
{   
    for(int PARTS = 0; PARTS < PSO_MAX_PARTICLES; PARTS++)
    {
        PSO_INIT_PARTICLE(PSO_STATE, &PSO_STATE->SWARM.PARTICLE[PARTS]);
    }
}

// CREATE THE INITIAL FITNESS BASIS BY WHICH THE PSO WILL OPERATE FROM
// THE FOLLOWING IMPLEMENTATION WILL ADOPT THE ANTENNA ARRAY DESIGN
// WHICH LOOKS TO MINIMISE THE AMOUNT OF RADIATION PERMEATING IN ONE
// DESIGNATED AREA OF THE ANTENNA'S RADIATION PATTERN
//
// THIS WAY, WE CAN IMPLEMENT A MORE CENTRALISED RADIATION PATTERN
static double PSO_ANTENNA_FITNESS(double* POSITION, int NUM_ANTENNAE, double TARGET_ANGLE)
{
    const double WAVELENGTH = PSO_ANTENNA_WAVELENGTH;
    const double K = 2.0 * M_PI / WAVELENGTH;
    
    // CALCULATE ARRAY FACTOR AT TARGET ANGLE
    double REAL_SUM = 0.0, IMAGE_SUM = 0.0;
    
    // DETERMINES THE CONCURRENT MAX SIDELOB VALUE
    // THIS WILL BE PARAMETISED TO ASSOCIATED WITH
    // THE SQUARE ROOT OF IT'S SUM IN ACCORDANCE WITH
    // THE COSINE AND SINE PROPERTIES OF THE PATTERN
    double MAX_SLL = 0.0;
    
    for(int SAMPLE = 0; SAMPLE < PSO_ANTENNA_SAMPLES; SAMPLE++)
    {
        double ANGLE = ((double)SAMPLE / PSO_ANTENNA_SAMPLES) * M_PI;
        
        // SKIP MAIN LOBE IF WE FOUND AN 
        // ABSOLUTE VALUE PERTAINING TOWARDS THE ANGLE
        if(fabs(ANGLE - TARGET_ANGLE) < PSO_MAINLOBE_WIDTH) continue;
        
        REAL_SUM = 0.0;
        IMAGE_SUM = 0.0;

        // ITERATE THROUGH OF THE ANTENNAE 
        // TO CREATE A REPRESENTATION OF THE PHASE
        // AND THE WAVELENGTH ASSOCIATED WITH SUCH

        // THE WAVELENGTH GOVERNS THE PATTERNS OF
        // THE RADIATION PATTERN - PHASE ALLOWS
        // FOR THE CONTINIOUS INTERPOLATION BETWEEN
        // POINTS TO CREATE SMOOTHER INTEGRALS 
        
        for(int INDEX = 0; INDEX < NUM_ANTENNAE; INDEX++)
        {
            double PHASE = POSITION[INDEX];
            double ELEMENT_POS = (double)INDEX * PSO_ANTENNA_SPACE * WAVELENGTH;
            double PHASE_SHIFT = K * ELEMENT_POS * sin(ANGLE);
            double TOTAL_PHASE = PHASE + PHASE_SHIFT;
            
            REAL_SUM += cos(TOTAL_PHASE);
            IMAGE_SUM += sin(TOTAL_PHASE);
        }
        
        // DEFINE THE SIDE LOBE AND ASSIGN IT TO THE MAX
        // THIS WILL BE OUR CONVERGENCE
        double SLL = sqrt(REAL_SUM * REAL_SUM + IMAGE_SUM * IMAGE_SUM) / (double)NUM_ANTENNAE;
        if(SLL > MAX_SLL) MAX_SLL = SLL;
    }
    
    return MAX_SLL;
}

// CALCULATE SWARM DIVERSITY ON THE PRESUPPOSED BASIS 
// OF A MEAN AVERAGE BETWEEN SWARM PARTICLES
//
// THIS WILL ASSUME THAT THERE IS A GREAT CLUSTER OF
// PARTICLES WITHIN SUCH A CONDENSED SPACE
//
// THIS IS ABOUT MITIGIATING THAT DISPARITY BY
// ACCOUNTING FOR A MAX IN A GIVEN AREA AND DISPERSING THAT
static double PSO_CALC_DIVERSITY(PSO* PSO_STATE)
{
    double DIVERSITY = 0.0;
    
    for(int DIMENSIONS = 0; DIMENSIONS < PSO_STATE->DIMENSIONS; DIMENSIONS++)
    {
        double MEAN = 0.0, SUM_SQ = 0.0;
        
        for(int PART = 0; PART < PSO_MAX_PARTICLES; PART++)
        {
            double POS = PSO_STATE->SWARM.PARTICLE[PART].POSITION[DIMENSIONS];
            MEAN += POS;
            SUM_SQ += POS * POS;
        }
        
        MEAN /= PSO_MAX_PARTICLES;
        DIVERSITY += sqrt(SUM_SQ / PSO_MAX_PARTICLES - MEAN * MEAN);
    }
    
    return DIVERSITY / PSO_STATE->DIMENSIONS;
}

// CREATE AN ADAPTIVE INERATIA WEIGHT SCHEME BY WHICH WE ARE
// ARE ABLE TO CHANGE THE MOTION OF THE PATTERN IN
// ACCORDANCE WITH THE GROWTH IN PARTICLES
static double PSO_ADAPTIVE_WEIGHT(PSO* PSO_STATE)
{
    static double INITIAL_DIVERSITY = -1.0;
    double CURRENT_DIVERSITY = PSO_CALC_DIVERSITY(PSO_STATE);
    
    if(INITIAL_DIVERSITY < 0.0)
    {
        INITIAL_DIVERSITY = CURRENT_DIVERSITY;
    }
    
    // NORMALIZE AND MAP TO WEIGHT RANGE
    double NORM_DIVERSITY = CURRENT_DIVERSITY / (INITIAL_DIVERSITY + INT_MAX);
    double WEIGHT_RANGE = PSO_INERTIA_MAX - PSO_INERTIA_MIN;
    double WEIGHT = PSO_INERTIA_MIN + (WEIGHT_RANGE * NORM_DIVERSITY);
    
    // CLAMP TO PREVENT SPILLOVER INTO OTHER PARTICLE SWARMS
    WEIGHT = PSO_INERTIA_MAX ? (WEIGHT > PSO_INERTIA_MAX) : WEIGHT;
    WEIGHT = PSO_INERTIA_MIN ? (WEIGHT > PSO_INERTIA_MIN) : WEIGHT;
    
    return WEIGHT;
}

// NOW WE CAN UPDATE ALL OF THE CORRESPONDENCE PERTAINING TOWARDS THE PARTICLES
// AND THEIR CLUSTER
//
// THE FOLLOWING WILL LOOK TO DETERMINE THE TWO KEY INERTIA COMPONENTS THAT
// ARE RESPONSIBLE FOR THE CONVERGENCE IN THE CLUSTER OVERTIME - SOCIAL AND COGNITIVE
//
// REMEMBERING THE PATHING ASSOCIATED AND UPDATING AGAINST THE CURRENT POSITION
static void PSO_UPDATE_PARTICLE(PSO* PSO_STATE, PSO_PARTICLE* PARTICLE, double INERTIA_WEIGHT)
{
    for(int DIMENSIONS = 0; DIMENSIONS < PSO_STATE->DIMENSIONS; DIMENSIONS++)
    {
        double COG_INERTIA = (double)rand() / RAND_MAX;         // THE RANDOMISED PATHING IN RELATION TO IT'S CURRENT BEST PATH
        double SOC_INERTIA = (double)rand() / RAND_MAX;         // THE BEST SET OF PHASE SHIFTS TO ANY PARTICLE
        
        // VELOCITY UPDATE WITH ADAPTIVE INERTIA
        double COGNITIVE = PSO_COG * COG_INERTIA * (PARTICLE->BEST_POS[DIMENSIONS] - PARTICLE->POSITION[DIMENSIONS]);
        double SOCIAL = PSO_SOC * SOC_INERTIA * (PSO_STATE->SWARM.GLOBAL_POS[DIMENSIONS] - PARTICLE->POSITION[DIMENSIONS]);
        
        PARTICLE->VELOCITY[DIMENSIONS] = (INERTIA_WEIGHT * PARTICLE->VELOCITY[DIM]) + COGNITIVE + SOCIAL;
        
        // CLAMP THE SEARCH TO A SPECIFIC RANGE ACCORDING TO THE VELOCITY 
        double SEARCH_RANGE = PSO_STATE->BOUNDS[DIMENSIONS].UPPER - PSO_STATE->BOUNDS[DIMENSIONS].LOWER;
        double MAX_VEL = SEARCH_RANGE * PSO_VELOCITY_CLAMP;
        
        if(PARTICLE->VELOCITY[DIMENSIONS] > MAX_VEL) PARTICLE->VELOCITY[DIMENSIONS] = MAX_VEL;
        if(PARTICLE->VELOCITY[DIMENSIONS] < -MAX_VEL) PARTICLE->VELOCITY[DIMENSIONS] = -MAX_VEL;
        
        PARTICLE->POSITION[DIMENSIONS] += PARTICLE->VELOCITY[DIMENSIONS];
        
        // BOUNDS CHECKING - THIS IS THE BEST I COULD DO HONESTLY
        if(PARTICLE->POSITION[DIMENSIONS] < PSO_STATE->BOUNDS[DIMENSIONS].LOWER)
        {
            PARTICLE->POSITION[DIMENSIONS] = PSO_STATE->BOUNDS[DIMENSIONS].LOWER;
            PARTICLE->VELOCITY[DIMENSIONS] *= -PSO_DAMP;
        }
        
        if(PARTICLE->POSITION[DIMENSIONS] > PSO_STATE->BOUNDS[DIMENSIONS].UPPER)
        {
            PARTICLE->POSITION[DIMENSIONS] = PSO_STATE->BOUNDS[DIMENSIONS].UPPER;
            PARTICLE->VELOCITY[DIMENSIONS] *= -PSO_DAMP;
        }
    }
}

// THE MAIN OPTIMISATION LOOP FOR THE ARRAY DESIGN
// PRESUPPOSES THAT BASED ON A MAX NUMBER OF ITERATIONS
// WE WILL LOOK TO DISTRIBUTE THE WEIGHT OF THE PATTERN ACCORDINGLY
// WITH DUE REGARD FOR A DESIGNATED ANGLE
//
// EXPLORES THE POSSIBLE CONFIGURATIONS OF THE PHASE SHIFT 
// TO ACHIEVE THE MOST OPTIMAL SLL SUPPRESSION 
int PSO_OPTIMIZE_ANTENNA(PSO* PSO_STATE, int NUM_ANTENNAE, double TARGET_ANGLE)
{
    PSO_INIT_SWARM(PSO_STATE);
    
    time_t START_TIME = time(NULL);
    
    for(int ITER = 0; ITER < PSO_MAX_ITERATIONS; ITER++)
    {
        if(difftime(time(NULL), START_TIME) >= PSO_LIMIT) break;
        
        double INERTIA_WEIGHT = PSO_ADAPTIVE_WEIGHT(PSO_STATE);
        
        for(int PART = 0; PART < PSO_MAX_PARTICLES; PART++)
        {
            PSO_PARTICLE* PARTICLE = &PSO_STATE->SWARM.PARTICLE[PART];
            
            // EVALUATE CURRENT FITNESS OF THE PARTICLE BASED
            // ON IT'S CHARACTERISTICS
            PARTICLE->CURRENT_FITNESS = PSO_ANTENNA_FITNESS
            (
                PARTICLE->POSITION, 
                NUM_ANTENNAE, 
                TARGET_ANGLE
            );
            
            // UPDATE PERSONAL BEST AGAINST THE CURRENT FITNESS
            // OF THE PARTICLE AND IT'S RESPECTIVE SPACE 
            if(PARTICLE->CURRENT_FITNESS < PARTICLE->BEST_FITNESS)
            {
                PARTICLE->BEST_FITNESS = PARTICLE->CURRENT_FITNESS;
                
                for(int DIM = 0; DIM < PSO_STATE->DIMENSIONS; DIM++)
                {
                    PARTICLE->BEST_POS[DIM] = PARTICLE->POSITION[DIM];
                }
            }
            
            // UPDATE GLOBAL BEST IN ACCORDANCE WITH THE SAME PARAMETERS
            // AND UPDATE ACCORDINGLY 
            if(PARTICLE->CURRENT_FITNESS < PSO_STATE->SWARM.GLOBAL_FITNESS)
            {
                PSO_STATE->SWARM.GLOBAL_FITNESS = PARTICLE->CURRENT_FITNESS;
                
                for(int DIM = 0; DIM < PSO_STATE->DIMENSIONS; DIM++)
                {
                    PSO_STATE->SWARM.GLOBAL_POS[DIM] = PARTICLE->POSITION[DIM];
                }
                
                PSO_IMPROVE(ITER, PSO_STATE->SWARM.GLOBAL_FITNESS, 
                           PSO_STATE->SWARM.GLOBAL_POS, PSO_STATE->DIMENSIONS);
            }
            
            PSO_UPDATE_PARTICLE(PSO_STATE, PARTICLE, INERTIA_WEIGHT);
        }
    }

    return 0;
}
