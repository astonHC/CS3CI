// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// SPECIFICALLY, THIS VERSION FOCUSSES MORE SO ON THE CONTENTS PERTAINING
// TOWARDS THE COURSEWORK - KEEPING MY ORIGINAL IMPLEMENTATION ADJACENT

// NESTED INCLUDES

#include "tsp.h"

// PROBABILITY HELPER FUNCTION TO HELP WITH
// CALCULATIONS PERTAINING TOWARDS THE HEURISTIC VALUE OF
// SELECTING THE NEW CITY BASED ON THE COLONY'S STATS
static double TSP_ACO_PROB(TSP_STATE* STATE, TSP_ACO_STATE* ACO_STATE, int CURRENT, int NEXT, int* VISITED)
{
    // HAVE WE ALREADY VISITED THIS CITY?
    if(VISITED[NEXT]) return 0.0;

    double PHER_PROB = ACO_STATE->PHEROMONE[CURRENT][NEXT];
    double DIST_PROB = (double)STATE->DIST.MATRIX[CURRENT][NEXT];

    if(DIST_PROB == 0)
    {
        TSP_HANDLE(ACO, TSP_ERROR_ACO, "INVALID DISTANCE FROM %d TO %d", CURRENT, NEXT);
        return 0.0;
    }

    // CALCULATE HEURISTIC (INVERSE OF DISTANCE - CLOSER IS BETTER)
    double ACO_HEUR = 1.0 / DIST_PROB;
    
    return pow(PHER_PROB, TSP_ACO_ALPHA) * pow(ACO_HEUR, TSP_ACO_HEUR);
}


// THIS FUNCTION ITERATES THROUGH ALL CITIES AND CALCULATES
// THE PROBABILITY OF VISITING EACH ONE FROM THE CURRENT POSITION
// IT RETURNS THE TOTAL SUM OF ALL PROBABILITIES
static double TSP_ACO_LIKELIHOOD(TSP_STATE* STATE, TSP_ACO_STATE* ACO_STATE, 
                                       int CURRENT, int* VISITED, double* LIKELIHOOD)
{
    double TOTAL = 0.0;
    
    // CALCULATE PROBABILITY FOR EACH CITY
    // LIKELIHOO IS DETERINED BY SAID PROBABILITY
    for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
    {
        LIKELIHOOD[INDEX] = TSP_ACO_PROB(STATE, ACO_STATE, CURRENT, INDEX, VISITED);
        TOTAL += LIKELIHOOD[INDEX];
    }
    
    return TOTAL;
}

// THIS FUNCTION IS USED AS A FALLBACK WHEN ALL PROBABILITIES ARE ZERO
// IT BUILDS A LIST OF UNVISITED CITIES AND RANDOMLY SELECTS ONE
static int TSP_ACO_SELECT_RANDOM(TSP_STATE* STATE, int* VISITED)
{
    int UNVISITED[TSP_MAX_CITIES];
    int COUNT = 0;
    int RESULT = -1;
    
    // ITERATE THROUGH ALL OF THE CITIS TO DETERMINE
    // IF WE HAVEN'T INDEX THROUGH THEM ALREADY
    for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
    {
        if(!VISITED[INDEX]) UNVISITED[COUNT++] = INDEX;
    }

    // CHECK IF WE HAVE UNVISITED CITIES
    if(COUNT == 0)
    {
        TSP_HANDLE(ACO, TSP_ERROR_ACO, "NO UNVISITED CITIES AVAILABLE", " ");
        return RESULT;
    }
    
    // RANDOMLY SELECT FROM UNVISITED CITIES
    RESULT = UNVISITED[rand() % COUNT];
    return RESULT;
}

// THIS IMPLEMENTS THE PROBABILISTIC SELECTION MECHANISM
// CITIES WITH HIGHER PROBABILITIES ARE MORE LIKELY TO BE CHOSEN
// BUT ANY CITY WITH NON-ZERO PROBABILITY CAN BE SELECTED
static int TSP_ACO_SELECT_ROULETTE(TSP_STATE* STATE, double* LIKELIHOOD, double TOTAL, int* VISITED)
{
    // GENERATE RANDOM VALUE IN RANGE [0, TOTAL]
    double RAND_VAL = ((double)rand() / RAND_MAX) * TOTAL;
    double SUM = 0.0;
    int SELECTED = -1;
    
    // ACCUMULATE PROBABILITIES UNTIL WE EXCEED RANDOM VALUE
    for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
    {
        if(VISITED[INDEX]) continue;
        
        // ADD THE SUM OF THE RANDOMISED TO THE LIKELIHOOD
        SUM += LIKELIHOOD[INDEX];

        // IS THE SUM GREATER THAN THE RANDOMISED VALUE?
        if(SUM >= RAND_VAL)
        {
            SELECTED = INDEX;
            return SELECTED;
        }
    }
    
    // RETURN LAST UNVISITED CITY AS A FAILSAFE
    // (ONLY REACHED DUE TO FLOATING POINT ROUNDING)
    for(int INDEX = STATE->CITY_COUNT - 1; INDEX >= 0; INDEX--)
    {
        if(!VISITED[INDEX])
        {
            SELECTED = INDEX;
            return SELECTED;
        }
    }
    
    return SELECTED;

}

// SELECT NEXT CITY BASED ON PROBABILITY OR RANDOM
// CALCULATES PROBABILITIES AND DELEGATES TO EITHER
// ROULETTE WHEEL OR RANDOM SELECTION BASED ON THE TOTAL
static int TSP_ACO_SELECT_NEXT(TSP_STATE* STATE, TSP_ACO_STATE* ACO_STATE, 
                                int CURRENT, int* VISITED)
{
    double LIKELIHOOD[TSP_MAX_CITIES];
    int NEXT_CITY = -1;
    
    // CALCULATE PROBABILITIES FOR ALL CITIES
    double TOTAL = TSP_ACO_LIKELIHOOD(STATE, ACO_STATE, CURRENT, VISITED, LIKELIHOOD);
    
    if(TOTAL == 0.0)
    {
        NEXT_CITY = TSP_ACO_SELECT_RANDOM(STATE, VISITED);
        return NEXT_CITY;
    }
    
    // ASSUMING THAT WE CANT FIND A PROBABILITY FOR THE NEXT
    // USE A RANDOM SELECT FROM THE ROULETTE 
    NEXT_CITY = TSP_ACO_SELECT_ROULETTE(STATE, LIKELIHOOD, TOTAL, VISITED);
    return NEXT_CITY;
}

// SIMULATES ONE ANT'S COMPLETE TOUR THROUGH ALL CITIES
// THE ANT STARTS FROM A RANDOM CITY AND PROBABILISTICALLY SELECTS
// SUBSEQUENT CITIES BASED ON PHEROMONE TRAILS AND DISTANCES
static void TSP_ACO_TOUR(TSP_STATE* STATE, TSP_ACO_STATE* ACO_STATE, 
                              int* PATH, int* DISTANCE)
{
    int VISITED[TSP_MAX_CITIES] = {0};
    
    // SELECT RANDOM STARTING CITY FOR THIS ANT
    int START_CITY = rand() % STATE->CITY_COUNT;
    int CURRENT = START_CITY;
    
    // INITIALISE PATH WITH STARTING CITY
    PATH[0] = CURRENT;
    VISITED[CURRENT] = 1;
    *DISTANCE = 0;
    
    // VISIT ALL REMAINING CITIES
    for(int STEP = 1; STEP < STATE->CITY_COUNT; STEP++)
    {
        // SELECT NEXT CITY BASED ON PROBABILITIES
        int NEXT = TSP_ACO_SELECT_NEXT(STATE, ACO_STATE, CURRENT, VISITED);
        
        // VALIDATE SELECTION
        if(NEXT < 0 || NEXT >= STATE->CITY_COUNT || VISITED[NEXT])
        {
            TSP_HANDLE(ACO, TSP_ERROR_ACO, "INVALID CITY SELECTION AT STEP %d, NEXT STEP %d", STEP, NEXT);
            *DISTANCE = INT_MAX;
            return;
        }
        
        // UPDATE PATH AND DISTANCE
        PATH[STEP] = NEXT;
        VISITED[NEXT] = 1;
        *DISTANCE += STATE->DIST.MATRIX[CURRENT][NEXT];
        CURRENT = NEXT;
    }
    
    // RETURN TO STARTING CITY TO COMPLETE THE TOUR
    PATH[STATE->CITY_COUNT] = START_CITY;
    *DISTANCE += STATE->DIST.MATRIX[CURRENT][START_CITY];

    // VALIDATE THE FINAL TOUR SHOULD IT MEET THE REQUIREMENTS
    if(*DISTANCE <= 0 || *DISTANCE == INT_MAX)
    {
        TSP_HANDLE(ACO, TSP_ERROR_ACO, "INVALID FINAL DISTANCE: %d", *DISTANCE);
        *DISTANCE = INT_MAX;
    }
}

// INITIALISE THE BASIS FOR THE ACO PHEROMONE MATRIX
//
// THE FOLLOWING PRESUPPOSES AN ELITIST STRATEGY WHEREBY THE BEST 
// ANT DEPOSITS EXTRA PHEROMONE 
//
// ALL EDGES START WITH EQUAL PHEROMONE TO GIVE ANTS INITIAL FREEDOM
void TSP_ACO_INIT(TSP_ACO_STATE* ACO_STATE, int CITY_COUNT)
{
    TSP_HANDLE(ACO, TSP_ERROR_NONE, "ACO INIT WITH %d CITIES\n", CITY_COUNT);
    
    // SET INITIAL PHEROMONE LEVELS FOR ALL EDGES
    for(int INDEX = 0; INDEX < CITY_COUNT; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < CITY_COUNT; ITERATOR++)
        {
            ACO_STATE->PHEROMONE[INDEX][ITERATOR] = TSP_ACO_PHER_RATE;
        }
    }
    
    // INITIALISE BEST DISTANCE TO MAXIMUM VALUE
    ACO_STATE->BEST_DIST = INT_MAX;
}

// PHEROMONE EVAPORATION SIMULATES THE NATURAL DECAY OF TRAILS
// EVAPORATION IS PROPORTIONAL BASED ON NATURUAL INITIALISATION OF 
// ANTS WITHIN A SPECIFIC TOUR
static void TSP_ACO_EVAPORATE(TSP_ACO_STATE* ACO_STATE, int CITY_COUNT)
{
    // APPLY EVAPORATION TO ALL EDGES
    for(int INDEX = 0; INDEX < CITY_COUNT; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < CITY_COUNT; ITERATOR++)
        {
            // REDUCE PHEROMONE BY EVAPORATION RATE
            ACO_STATE->PHEROMONE[INDEX][ITERATOR] *= (1.0 - TSP_ACO_EVAP);
            
            // ENSURE MINIMUM PHEROMONE LEVEL TO MAINTAIN EXPLORATION
            ACO_STATE->PHEROMONE[INDEX][ITERATOR] = 
                (ACO_STATE->PHEROMONE[INDEX][ITERATOR] < TSP_ACO_PHER_MIN) ? 
                TSP_ACO_PHER_MIN : ACO_STATE->PHEROMONE[INDEX][ITERATOR];
                
            ACO_STATE->PHEROMONE[INDEX][ITERATOR] = 
                (ACO_STATE->PHEROMONE[INDEX][ITERATOR] > TSP_ACO_PHER_MAX) ? 
                TSP_ACO_PHER_MAX : ACO_STATE->PHEROMONE[INDEX][ITERATOR];
        }
    }
}

// EACH ANT DEPOSITS PHEROMONE ON THE EDGES IT TRAVERSED
// THE AMOUNT DEPOSITED IS INVERSELY PROPORTIONAL TO TOUR LENGTH
// SHORTER TOURS RECEIVE MORE PHEROMONE
static void TSP_ACO_DEPOSIT_ALL(TSP_ACO_STATE* ACO_STATE, TSP_STATE* STATE, 
                                 int (*PATHS)[TSP_MAX_CITIES + 1], int* ANT_DIST)
{
    int CITY_COUNT = STATE->CITY_COUNT;
    
    // PROCESS EACH ANT'S CONTRIBUTION
    for(int ANT = 0; ANT < TSP_ACO_ANTS; ANT++)
    {
        // ADDED PROTECTION FOR EDGE CASES TO PREVENT DIV BY ZERO
        if(ANT_DIST[ANT] <= 0 || ANT_DIST[ANT] == INT_MAX) continue;

        // CALCULATE PHEROMONE DEPOSIT (SHORTER = MORE PHEROMONE)
        double DEPOSIT = TSP_ACO_DEPO / (double)ANT_DIST[ANT];
        
        // DEPOSIT ON ALL EDGES IN THIS ANT'S PATH
        for(int INDEX = 0; INDEX < CITY_COUNT; INDEX++)
        {
            int FROM = PATHS[ANT][INDEX];
            int TO = PATHS[ANT][INDEX + 1];
            
            // UPDATE BOTH DIRECTIONS
            ACO_STATE->PHEROMONE[FROM][TO] += DEPOSIT;
            ACO_STATE->PHEROMONE[TO][FROM] += DEPOSIT;
        }
    }
}


// THIS IMPLEMENTS THE ELITIST APPROACH WHERE THE BEST ANT
// IN THE CURRENT ITERATION DEPOSITS ADDITIONAL PHEROMONE
// THIS REINFORCES GOOD SOLUTIONS MORE STRONGLY

static void TSP_ACO_DEPOSIT_ELITE(TSP_ACO_STATE* ACO_STATE, TSP_STATE* STATE,
                                   int (*PATHS)[TSP_MAX_CITIES + 1], int* ANT_DIST, int BEST_ANT)
{
    int CITY_COUNT = STATE->CITY_COUNT;

    if(ANT_DIST[BEST_ANT] <= 0 || ANT_DIST[BEST_ANT] == INT_MAX) 
        return;
    
    // ELITE ANT DEPOSITS DOUBLE THE NORMAL AMOUNT
    double ELITE = (TSP_ACO_DEPO * TSP_ACO_ELITE) / (double)ANT_DIST[BEST_ANT];
    
    // DEPOSIT EXTRA PHEROMONE ON BEST ANT'S PATH
    for(int INDEX = 0; INDEX < CITY_COUNT; INDEX++)
    {
        int FROM = PATHS[BEST_ANT][INDEX];
        int TO = PATHS[BEST_ANT][INDEX + 1];
        
        // APPLY ELITE REINFORCEMENT
        ACO_STATE->PHEROMONE[FROM][TO] += ELITE;
        ACO_STATE->PHEROMONE[TO][FROM] += ELITE;

        // APPLY A MAXIMUM PHERMONE CAP AFTER DEPOSIT
        // TO PREVENT AGGREGIOUS OVERFLOWING OF EDGE CASES
        if(ACO_STATE->PHEROMONE[FROM][TO] > TSP_ACO_PHER_MAX)
            ACO_STATE->PHEROMONE[FROM][TO] = TSP_ACO_PHER_MAX;
        if(ACO_STATE->PHEROMONE[TO][FROM] > TSP_ACO_PHER_MAX)
            ACO_STATE->PHEROMONE[TO][FROM] = TSP_ACO_PHER_MAX;
    }
}

// THIS FUNCTION COORDINATES THE THREE-STEP PHEROMONE UPDATE:
// 1. EVAPORATE EXISTING PHEROMONES
// 2. DEPOSIT PHEROMONES FROM ALL ANTS
// 3. APPLY ELITIST STRATEGY FOR BEST ANT
static void TSP_ACO_UPDATE_PHER(TSP_ACO_STATE* ACO_STATE, TSP_STATE* STATE, 
                         void* ANT_PATHS, int* ANT_DIST, int BEST_ANT)
{
    int CITY_COUNT = STATE->CITY_COUNT;

    // TYPECAST FOR DESIGNATED PATHS IN RELATION TO THE CITIES
    // ANT_PATHS JUST REPRESENT THE BASIS OF SUCH
    int (*PATHS)[TSP_MAX_CITIES + 1] = (int (*)[TSP_MAX_CITIES + 1])ANT_PATHS;
    
    TSP_ACO_EVAPORATE(ACO_STATE, CITY_COUNT);    
    TSP_ACO_DEPOSIT_ALL(ACO_STATE, STATE, PATHS, ANT_DIST);    
    TSP_ACO_DEPOSIT_ELITE(ACO_STATE, STATE, PATHS, ANT_DIST, BEST_ANT);
}


// THIS FUNCTION SEARCHES THROUGH ALL ANTS IN THE CURRENT ITERATION
// TO FIND THE ONE WITH THE SHORTEST TOUR DISTANCE
static int TSP_ACO_FIND_BEST(int* ANT_DIST, int* BEST_DIST)
{
    int BEST_ANT = 0;
    *BEST_DIST = INT_MAX;
    
    // COMPARE ALL ANT DISTANCES
    for(int ANT = 0; ANT < TSP_ACO_ANTS; ANT++)
    {
        // ALWAYS PRESUPPOSE THE BEST DIST
        // FOR THE CURRENT ANT (THE ONE WITH THE SHORTEST DIST)
        if(ANT_DIST[ANT] > 0 && ANT_DIST[ANT] < INT_MAX)
        {
            if(ANT_DIST[ANT] < *BEST_DIST)
            {
                *BEST_DIST = ANT_DIST[ANT];
                BEST_ANT = ANT;
            }
        }
    }
    
    return BEST_ANT;
}

// IF THE CURRENT ITERATION'S BEST ANT FOUND A BETTER SOLUTION
// THAN THE GLOBAL BEST, UPDATE THE GLOBAL BEST AND DISPLAY IT
static void TSP_ACO_UPDATE_BEST(TSP_ACO_STATE* ACO_STATE, TSP_STATE* STATE,
                                 int (*ANT_PATHS)[TSP_MAX_CITIES + 1], int BEST_ANT, int BEST_DIST)
{
    // ONLY UPDATE IF WE FOUND AN IMPROVEMENT
    if(BEST_DIST < ACO_STATE->BEST_DIST)
    {
        ACO_STATE->BEST_DIST = BEST_DIST;
        
        for(int INDEX = 0; INDEX <= STATE->CITY_COUNT; INDEX++)
        {
            ACO_STATE->BEST_PATH[INDEX] = ANT_PATHS[BEST_ANT][INDEX];
        }

        // PRINT OUT THE CREDENTIALS PERTAINING TOWARDS IMPROVEMENT        
        TSP_IMPROVE(STATE->ALGO, ACO_STATE->BEST_PATH, 
        ACO_STATE->BEST_DIST, STATE->CITY_COUNT);
    }
}

// DIAGNOSTIC FUNCTION TO MONITOR PHEROMONE DISTRIBUTION
// HELPS IDENTIFY IF PREMATURE CONVERGENCE IS OCCURRING
// BY CHECKING MIN/MAX/AVG PHEROMONE LEVELS AND THEIR RATIO
static void TSP_ACO_STATS(TSP_ACO_STATE* ACO_STATE, int CITY_COUNT)
{
    double MIN = INT_MAX;
    double MAX = 0;
    double AVG = 0;
    int COUNT = 0;
    
    // CALCULATE PHEROMONE STATISTICS ACROSS ALL EDGES
    for(int INDEX = 0; INDEX < CITY_COUNT; INDEX++)
    {
        for(int ITERATOR = INDEX + 1; ITERATOR < CITY_COUNT; ITERATOR++)
        {
            double PHER = ACO_STATE->PHEROMONE[INDEX][ITERATOR];

            // SET ALL OF THE CORRESPONDENCE
            MIN = (PHER < MIN) ? PHER : MIN;
            MAX = (PHER > MAX) ? PHER : MAX;
            AVG += PHER;
            COUNT++;
        }
    }

    AVG /= COUNT;        
    TSP_HANDLE(ACO, TSP_ERROR_NONE, 
               "PHEROMONE - MIN: %.4f | AVG: %.4f | MAX: %.4f | RATIO: %.2fx\n",
               MIN, AVG, MAX, MAX / MIN);
}

// DIAGNOSTIC FUNCTION TO TRACK ANT DIVERSITY
// MEASURES HOW MANY UNIQUE SOLUTIONS EXIST IN CURRENT ITERATION
// LOW DIVERSITY INDICATES PREMATURE CONVERGENCE
static void TSP_ACO_DIVERSITY(int (*ANT_PATHS)[TSP_MAX_CITIES + 1], 
                                         int* ANT_DIST, int CITY_COUNT)
{
    int UNIQUE_DISTANCES = 0;
    int COUNTED[TSP_ACO_ANTS] = {0};
    
    // COUNT UNIQUE DISTANCE VALUES AMONG ALL ANTS
    for(int INDEX = 0; INDEX < TSP_ACO_ANTS; INDEX++)
    {
        // HAVE THE ANTS ALREADY REACHED THIS DISTANCE?
        if(COUNTED[INDEX]) continue;
        
        // INCREMENT THE UNIQUE PATTERNS IN THE DISTANCE TRAVELLED
        UNIQUE_DISTANCES++;
        for(int ITERATOR = INDEX + 1; ITERATOR < TSP_ACO_ANTS; ITERATOR++)
        {
            if(ANT_DIST[INDEX] == ANT_DIST[ITERATOR]) COUNTED[ITERATOR] = 1;
        }
    }
    
    // FIND MIN AND MAX DISTANCES IN THIS ITERATION
    int MIN_DIST = INT_MAX;
    int MAX_DIST = 0;
    for(int INDEX = 0; INDEX < TSP_ACO_ANTS; INDEX++)
    {
        MIN_DIST = (ANT_DIST[INDEX] < MIN_DIST) ? ANT_DIST[INDEX] : MIN_DIST;
        MAX_DIST = (ANT_DIST[INDEX] > MAX_DIST) ? ANT_DIST[INDEX] : MAX_DIST;
    }
    
    TSP_HANDLE(ACO, TSP_ERROR_NONE,
               "ANT DIVERSITY - UNIQUE: %d/%d | RANGE: [%d - %d] | SPREAD: %d",
               UNIQUE_DISTANCES, TSP_ACO_ANTS, MIN_DIST, MAX_DIST, MAX_DIST - MIN_DIST);
}

// CREATE THE BASIS FOR ALL OF THE ENCOMPASSING ACO FUNCTIONALITY
// WHAT MAKES THIS DIFFERENT TO THE ABOVE IS THAT THIS ACTUALLY
// GOES OVER THE ITERATIONS - RATHER THAN JUST INITIALISING THE 
// INDEXXING FOR THE MATRIX
int TSP_ACO_BASE(TSP_STATE* STATE, int MAX_ITER)
{
    TSP_ACO_STATE* ACO_STATE = malloc(sizeof(TSP_ACO_STATE));
    
    if(ACO_STATE == NULL) goto ACO_NULL;
    
    TSP_ACO_INIT(ACO_STATE, STATE->CITY_COUNT);
    TSP_NEAREST(STATE);

    // ALLOCATE SPACE FOR ANT PATHS AND DISTANCES
    int ANT_PATHS[TSP_ACO_ANTS][TSP_MAX_CITIES + 1];
    int ANT_DIST[TSP_ACO_ANTS];
    int ITERATION = 0;

    TSP_HANDLE(ACO, TSP_ERROR_NONE, "ACO STARTING WITH %d ANTS AND %d ITERATIONS\n", 
               TSP_ACO_ANTS, MAX_ITER);

    // DETERMINE THE AMOUNT OF ITERATIONS FOR THE LIFETIME OF THE ALGO
    // THE IDEA IS TO DETERMINE THE DISTANCE OF THE ANTS IN RELATION 
    // TO THE HEURISTIC PROBABILTITY OF TRAVELLING TO ANOTHER CITY

    // WE ARE PRETTY MUCH CONCERNED WITH THE LIFETIME OF THE COLONY
    // IN RELATION TO THEIR PHEROMONE'S

    for(ITERATION = 0; ITERATION < MAX_ITER; ITERATION++)
    {
        // SIMULATE ALL ANTS FOR THIS ITERATION
        for(int ANT = 0; ANT < TSP_ACO_ANTS; ANT++)
        {
            TSP_ACO_TOUR(STATE, ACO_STATE, ANT_PATHS[ANT], &ANT_DIST[ANT]);
        }
        
        int BEST_DIST;
        int BEST_ANT = TSP_ACO_FIND_BEST(ANT_DIST, &BEST_DIST);
        
        // CHECK FOR INFORMATION PER EVERY INTERVAL
        if(ITERATION % TSP_DIAG_INTERVAL == 0)
        {
            TSP_HANDLE(ACO, TSP_ERROR_NONE, 
                       "ITERATION %d", ITERATION);

            TSP_ACO_DIVERSITY(ANT_PATHS, ANT_DIST, STATE->CITY_COUNT);
            TSP_ACO_STATS(ACO_STATE, STATE->CITY_COUNT);
        }
        
        TSP_ACO_UPDATE_BEST(ACO_STATE, STATE, ANT_PATHS, BEST_ANT, BEST_DIST);        
        TSP_ACO_UPDATE_PHER(ACO_STATE, STATE, ANT_PATHS, ANT_DIST, BEST_ANT);
    }

    TSP_HANDLE(ACO, TSP_ERROR_NONE, "FINAL ITERATION %d", ITERATION);
    TSP_HANDLE(ACO, TSP_ERROR_NONE, "ACO COMPLETE - FINAL BEST: %d", 
               ACO_STATE->BEST_DIST);

    // STORE AND SET THE BEST PATHING AS THE FINAL RESULT
    for(int INDEX = 0; INDEX <= STATE->CITY_COUNT; INDEX++)
        STATE->TOUR.TSP_PATH[INDEX] = ACO_STATE->BEST_PATH[INDEX];
    
    free(ACO_STATE);
    return 0;

ACO_NULL:
    TSP_MEM_ERROR(ACO_STATE);
    TSP_ERROR_HANDLE(ACO, TSP_ERROR_ACO, "WITH CITY COUNT %d", STATE->CITY_COUNT);
    return 1;
}
