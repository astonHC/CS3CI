// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// SPECIFICALLY, THIS VERSION FOCUSSES MORE SO ON THE CONTENTS PERTAINING
// TOWARDS THE COURSEWORK - KEEPING MY ORIGINAL IMPLEMENTATION ADJACENT

// NESTED INCLUDES

#include "tsp.h"

// PROBABILITY HELPER FUNCTION TO HELP WITH
// CALCULATIONS PERTAINING TOWARDS THE HEURISTIC VALUE OF
// SELECTING THE NEW CITY BASED ON THE COLONY'S STATS

double TSP_ACO_PROB(TSP_STATE* STATE, TSP_ACO_STATE* ACO_STATE, int CURRENT, int NEXT, int* VISITED)
{
    // HAVE WE ALREADY VISITED IN THIS PROBABILITY?
    if(VISITED[NEXT]) goto TSP_ACO_VISIT;

    // DETERMINE THE PROBABILITY OF THE STATS OF THE COLONY
    double PHER_PROB = ACO_STATE->PHEROMONE[CURRENT][NEXT];
    double DIST_PROB = (double)STATE->DIST.MATRIX[CURRENT][NEXT];
    double ACO_HEUR = 1.0 / DIST_PROB;

    if(DIST_PROB == 0) goto TSP_ACO_VISIT;

    return pow(PHER_PROB, TSP_ACO_ALPHA) * pow(ACO_HEUR, TSP_ACO_HEUR);

    TSP_ACO_VISIT:
        TSP_ERROR_HANDLE(ACO, TSP_ERROR_NONE, "THE NEXT CITY %s HAS ALREADY BEEN VISITED\n", STATE->CITY->NAME);
}

// INITIALISE THE BASIS FOR THE ACO PHEROMONE MATRIX
// THE FOLLOWING PRESUPPOSES AN ELITIST STRATEGY WHEREBY THE BEST 
// ANT DEPOSITS EXTRA PHEROMONE 
//
// DEPOSITION IS THE PENULTIMATE RESULT OF THE INCREASE IN PHEROMONE
void TSP_ACO_INIT(TSP_ACO_STATE* ACO, int CITY_COUNT)
{
    // CREATE THE INITIAL PHERMONE UPDATE HEURISTIC
    // THIS IS DONE BY DETERMINING THE CONTRIBUTIONS OF
    // THE ANTS WITHIN THE CYCLE
    
    for(int INDEX = 0; INDEX < CITY_COUNT; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < CITY_COUNT; ITERATOR++)
        {
            ACO->PHEROMONE[INDEX][ITERATOR] = TSP_ACO_PHER_RATE;
        }
    }

    ACO->BEST_DIST = INT_MAX;
    TSP_HANDLE(NONE, TSP_ERROR_NONE, 
        "ANT COLONY INITIALISED WITH PHERMONE RATE: %.2f AND BEST DIST %d\n", 
        TSP_ACO_PHER_RATE, ACO->BEST_DIST);
}

// CREATE THE BASIS FOR ALL OF THE ENCOMPASSING ACO FUNCTIONALITY
// WHAT MAKES THIS DIFFERENT TO THE ABOVE IS THAT THIS ACTUALLY
// GOES OVER THE ITERATIONS - RATHER THAN JUST INITIALISING THE 
// INDEXXING FOR THE MATRIX

int TSP_ACO_BASE(TSP_STATE* STATE, int MAX_ITER)
{
    TSP_ACO_STATE* ACO_STATE;
    TSP_ACO_INIT(&ACO_STATE, STATE->CITY_COUNT);

    if(ACO_STATE == NULL) goto ACO_NULL;

    int ANT_PATHS[TSP_ACO_ANTS][TSP_MAX_CITIES + 1];
    int ANT_DIST[TSP_ACO_ANTS];

    TSP_HANDLE(ACO, TSP_ERROR_NONE, "ACO INIT WITH %d ANTS\n", TSP_ACO_ANTS);

    time_t START_TIME = time(NULL);
    int ITERATION = 0;

    // DETERMINE THE AMOUNT OF ITERATIONS FOR THE LIFETIME OF THE ALGO
    // THE IDEA IS TO DETERMINE THE DISTANCE OF THE ANTS IN RELATION 
    // TO THE HEURISTIC PROBABILTITY OF TRAVELLING TO ANOTHER CITY

    // WE ARE PRETTY MUCH CONCERNED WITH THE LIFETIME OF THE COLONY
    // IN RELATION TO THEIR PHEROMONE'S

    while(ITERATION < MAX_ITER && (time(NULL), START_TIME) >= 0.0)
    {
        int BEST_ANT = 0;
        int BEST_DIST = INT_MAX;

        // DETERMINE THE BEST POSSIBLE SOLUTION FOR ALL 
        // OF THE ANTS WITHIN THE COLONY
        // 
        // THIS IS DONE THROUGH THE HEURISTIC MEASUREMENT
        // OF THE TOUR OF EACH COLONY

        for(int ANT = 0; ANT < TSP_ACO_ANTS; ANT++)
        {
            // HAVE WE VISITED FIRST AND FOREMOST?
            // DEFINE THE CONDITIONS FOR SUCH

            int VISITED[TSP_MAX_CITIES] = {0};
            int CURRENT = 0;

            // MAP THE CORRESPONDENCE
            ANT_PATHS[ANT][0] = CURRENT;
            VISITED[CURRENT] = 1;
            ANT_DIST[ANT] = 0;

            // FROM HERE, WE CAN DETERMINE THE PATH BASED ON THE 
            // NEXT CITY IN THE PROBABILITY

            for(int STEP = 1; STEP < STATE->CITY_COUNT; STEP++)
            {
                double LIKELIHOOD[TSP_MAX_CITIES];
                double TOTAL = 0.0;

                // DETERMINE SAID LIKELIHOOD AGAINST THE CURRENT PHERMONE
                // AND DISTANCE OF THE COLONY
                for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
                {
                    LIKELIHOOD[INDEX] = TSP_ACO_PROB(STATE, &ACO_STATE, CURRENT, INDEX, VISITED);
                    TOTAL += LIKELIHOOD[INDEX];
                }
            }
        }
    }

    STATE->TOUR.TSP_TOTAL_DIST = ACO_STATE->BEST_DIST;
    return 0;

    ACO_NULL:
        TSP_MEM_ERROR(ACO_STATE);
        TSP_ERROR_HANDLE(ACO, TSP_ERROR_ACO, "WITH CITY COUNT %d\n", STATE->CITY_COUNT);
}
