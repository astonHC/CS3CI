// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// SPECIFICALLY, THIS FILE FOCUSSES ON THE MODULARISATION OF UTILITY
// USED THROUGHOUT THE IMPLEMENTATION - KEPT IN A SEPERATE FILE TO 
// REDUCE CLUTTER

// NESTED INCLUDES 

#include "tsp.h"

// CALCULATES THE EUCLIDEAN DISTANCE BETWEEN EACH CITY
// THE COMMONALITY WITH THE TSP IS THAT WE ALWAYS PRESUPPOSE
// THAT EACH OF THE CITY ARE REPRESENTED BY PLANAR MAPPING
//
// WHICH MAKES ACCOUNTING FOR AXIS' A LOT EASIER 
int TSP_EUC_DIST(const TSP_CITY* CITY_A, const TSP_CITY* CITY_B) 
{
    int DIST_X = CITY_A->X - CITY_B->X;
    int DIST_Y = CITY_A->Y - CITY_B->Y;

    // FORCE TYPE CAST FOR DISTANCE
    // WE LEVERAGE INT FOR GREATER PRECISION
    // SQUARE ROOT HELPS WITH PRECISION MULTIPLICATION
    return (int)sqrt(DIST_X * DIST_X + DIST_Y * DIST_Y);
}

// CALCULATES THE DISTANCE MATRIX FOR ALL CITY PAIRS
// UTILISES MATRIX ADDITION TO INDEX THROUGH THE RESPECTIVE CITY COUNT
// AND DETERMINES THE DISTANCE BETWEEN THEM
void TSP_CALC_DIST(TSP_STATE* STATE)
{
    // DETERMINE THE DISTANCE SIZE BASED ON THE NUMBER OF CITIES
    // WHICH WILL GROW EXPONENTIALLY 
    STATE->DIST.SIZE = STATE->CITY_COUNT;

    for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < STATE->CITY_COUNT; ITERATOR++)
        {
            // IF ANY TWO CITIES ARE NOT THE SAME
            if(INDEX != ITERATOR)
            {
                // CHECK THE DISTANCE BETWEEN SUCH
                // CASTING IT AS SUCH HELPS ESPECIALLY WITH THE DEBUG INFO
                int DISTANCE = TSP_EUC_DIST(&STATE->CITY[INDEX], &STATE->CITY[ITERATOR]);
                STATE->DIST.MATRIX[INDEX][ITERATOR] = DISTANCE;

                TSP_DEBUG_DIST(DIST, TSP_ERROR_NONE, INDEX, ITERATOR, DISTANCE, 
                    " - %s TO %s", STATE->CITY[INDEX].NAME, STATE->CITY[ITERATOR].NAME);
            }
            else
            {
                STATE->DIST.MATRIX[INDEX][ITERATOR] = 0;
            }
        }
    }
}

// SIMPLE DISPATCH FUNCTION FOR GETTING THE 
// CORRESPONDING ALGORITHM TYPE - PREVENTING UNWANTED EXECUTIONS
int TSP_ALGO_CHOICE(TSP_STATE* STATE, TSP_ALGO ALGO)
{
    switch (ALGO)
    {
        case TSP_NN:
            TSP_NEAREST(STATE);
            break;

        case TSP_ACO:
            printf("NOT YET IMPLEMENTED");
            return 1;

        case TSP_LS:
            TSP_TWO_OPT(STATE);
            return 1;
    
        default:
            printf("INVALID ALGORITHM\n");
            return 1;
        break;
    }

    return 0;
}
