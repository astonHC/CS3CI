// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// SPECIFICALLY, THIS VERSION FOCUSSES MORE SO ON THE CONTENTS PERTAINING
// TOWARDS THE COURSEWORK - KEEPING MY ORIGINAL IMPLEMENTATION ADJACENT

// NESTED INCLUDES 

#include "tsp.h"

// REVERSE A CONCURRENT SEGMENT OF THE SEARCH
// WHICH PRESUPPOSES THAT THERE IS A SWAP THAT NEEDS TO OCCUR
// IN ORDER TO BRING ABOUT A BETTER SOLUTION FOR CLOSEST SEARCH
//
// THE FOLLOWING GETS A TEMPORARY SWAP SOLUTION BASED ON THE START,
// MAPS TO THE END, REVERSES AND INC/DEC ACCORDINGLY 
void TSP_REVERSE(int* TOUR, int START, int END)
{
    while(START < END)
    {
        int SWAP = TOUR[START];
        TOUR[START] = TOUR[END];
        TOUR[END] = SWAP;
        START++;
        END--;
    }
}

// HELPER FUNCTION TO BE ABLE TO DISCERN THE 
// TOTAL DISTANCE OF A TOUR
//
// MAPS TO AND FROM BASED ON CURRENT OFFSET AND 
// ADDS THAT TO THE CONCURRENT MATRIX ADDITION 
int TSP_TOUR_DIST(TSP_STATE* STATE, int* TOUR)
{
    int TOTAL = 0;
    int FROM_POS = 0;
    int TO_POS = 0;

    for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
    {
        FROM_POS = TOUR[INDEX];
        TO_POS = TOUR[INDEX + 1];
        TOTAL += STATE->DIST.MATRIX[FROM_POS][TO_POS];
    }

    TSP_HANDLE(NONE, TSP_ERROR_NONE, "TOTAL DISTANCE COVERED BY CURRENT TOUR: %d", TOTAL);
    TSP_DEBUG_DIST(DIST, TSP_ERROR_NONE, FROM_POS, TO_POS, TOTAL, " ", " ");
    return TOTAL;
}

// IMPLEMENT THE BASIS FOR THE NOVEL VARIANT OF MY TSP IMPLEMENTATION
// NEAREST NEIGHBOUR IS LEVERAGED TO BE ABLE TO PROVIDE A POINT
// OF COMPARISON BETWEEN THE RUNTIME OF THE ALGORITHM
//
// I HAVE OPTED FOR LOCAL SEARCH ON THE PREASSUMED BASIS OF IT 
// BEING FASTER AT DETERMINING THE BEST ROUTE IN ACCORDANCE WITH 
int TSP_TWO_OPT(TSP_STATE* STATE)
{
    // PROVIDE THE INITAL BASIS FOR SEARCH
    TSP_NEAREST(STATE);

    int CURRENT_TOUR[TSP_MAX_CITIES + 1];
    int BEST_TOUR[TSP_MAX_CITIES + 1];

    TSP_HANDLE(NONE, TSP_ERROR_NONE, "LOCAL SEARCH STARTING FROM: %s\n", 
        STATE->CITY[0].NAME);

    // COPY THE INITIAL TOUR FROM THE PREVIOUS
    for(int INDEX = 0; INDEX <= STATE->CITY_COUNT; INDEX++)
    {
        CURRENT_TOUR[INDEX] = STATE->TOUR.TSP_PATH[INDEX];
        BEST_TOUR[INDEX] = STATE->TOUR.TSP_PATH[INDEX];
    }

    int BEST_DIST = STATE->TOUR.TSP_TOTAL_DIST;
    int CURRENT_DIST = BEST_DIST;               // ALWAYS ASSUME THE CURRENT IS THE BEST UNLESS SWAPPED
    int IMPROVEMENTS = 0;

    TSP_HANDLE(NONE, TSP_ERROR_NONE, "LOCAL SEARCH - INITIAL SOLUTION: %d FROM %s", 
        BEST_DIST, STATE->CITY[0].NAME);

    // NOW BEGIN TO DEFINE THE TIME TAKEN TO COMPLETE THE SEARCH
    // THIS WILL THEN BE USED AS A POINT OF COMPARISON TO IDENTIFY THE COST

    time_t START_TIME = time(NULL);
    int CURRENT_ITER = 0;

    // LEVERAGE STANDARD LIBRARY TIME COMPARISON FUNCTION
    // FOR EASE OF USE 
    while(difftime(time(NULL), START_TIME) < 30.0)
    {
        int IMPROVED = 0;

        // DETERMINE THE AMOUNT OF CITIES FIRST AND FOREMOST 
        // BEFORE ACTING UPON THE SWAP

        // THIS IS DONE BY CHECKING ALL VALID SEGMENT PAIRS BASED ON EDGE CASES
        // AS OPPOSED TO CHECKING FOR THE INDEXXING OF THE CITY HOLISTICALLY

        // 20/10/25:
        // WE START AT INDEX = 1 TO PREVENT UNSEEN INDEXXES
        // GIVEN THE GREEDY SOLUTION OF LS, THESE ARRAYS WILL 
        // START AT 1 - 0 IS CONSIDERED OOB

        for(int INDEX = 1; INDEX < STATE->CITY_COUNT; INDEX++)
        {
            for(int ITERATOR = INDEX + 1; ITERATOR < STATE->CITY_COUNT; ITERATOR++)
            {
                // SANITY CHECK AMIDST DEBUGGING
                if(INDEX <= 0) { TSP_ERROR_HANDLE(OOB, TSP_ERROR_OOB, "VALUE: %d\n", INDEX); }

                // CALCULATE IMPROVEMENT FRM SWAP BASED ON DELTATIME
                // DELATIME PRESUPPOSES THE TIME ELAPSED FROM THE LAST 
                // FRAME TO THE CURRENT (FRAME IN THIS CONTEXT BEING ITERATION)

                // THE FOLLOWING LOOKS TO REPRESENT A TWO-DIMENSIONAL ARRAY
                // OF THE TIME TAKEN BETWEEN ALL POSSIBLE COMBINATIONS FOR INDEXXING

                int DELTA = 0;

                // REMOVE OLD EDEGS
                DELTA -= STATE->DIST.MATRIX[CURRENT_TOUR[INDEX-1]][CURRENT_TOUR[INDEX]];
                DELTA -= STATE->DIST.MATRIX[CURRENT_TOUR[ITERATOR]][CURRENT_TOUR[ITERATOR+1]];

                // ADD NEW EDGES
                DELTA += STATE->DIST.MATRIX[CURRENT_TOUR[INDEX-1]][CURRENT_TOUR[ITERATOR]];
                DELTA += STATE->DIST.MATRIX[CURRENT_TOUR[INDEX]][CURRENT_TOUR[ITERATOR+1]];
                
                // IF WE DONT HAVE ANY NEW SWAPS
                // WITHIN THE TIME FRAME
                if(DELTA < 0)
                {
                    // PERFROM THE LOCAL SWAP AGAINST THE EDGE CASES
                    TSP_REVERSE(CURRENT_TOUR, INDEX, ITERATOR);

                    // DISCERN THE NEW DISTANCE FROM THIS SWAP AND DETERMINE
                    // IF THE SWAP IN TERMS OF COST, IS BETTER THAN THE PREVIOUS
                    CURRENT_DIST += DELTA;

                    // IF THE NEW DISTANCE IS LESS
                    // THEN WE SHOULD BE SURE TO MAP IT TO VALIDATE THE IMPROVEMENT

                    if(CURRENT_DIST < BEST_DIST)
                    {
                        BEST_DIST = CURRENT_DIST;
                        for(int TOUR_INDEX = 0; TOUR_INDEX <= STATE->CITY_COUNT; TOUR_INDEX++)
                        {
                            BEST_TOUR[TOUR_INDEX] = CURRENT_TOUR[TOUR_INDEX];
                        }

                        IMPROVEMENTS++;
                        TSP_IMPROVE(STATE->ALGO, BEST_TOUR, BEST_DIST, STATE->CITY_COUNT);
                    }

                    IMPROVED = 1;
                }
            }
        }

        CURRENT_ITER++;

        // IF NO IMPROVEMENTS HAVE BEEN MADE, WE HAVE REACHED THE OPTIMAL PATH
        if(!IMPROVED)
        {
            TSP_HANDLE(NONE, TSP_ERROR_NONE, "LOCAL SEARCH HAS REACHED OPTIMAL PATH AFTER %d ITERATIONS, IMPROVEMENTS: %d\n", CURRENT_ITER, IMPROVEMENTS);
            break;
        }
    }

    TSP_TOUR_DIST(STATE, CURRENT_TOUR);

    for(int STORE = 0; STORE <= STATE->CITY_COUNT; STORE++)
    {
        STATE->TOUR.TSP_PATH[STORE] = BEST_TOUR[STORE];
    }

    STATE->TOUR.TSP_TOTAL_DIST = BEST_DIST;
    return 0;
}