// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// SPECIFICALLY, THIS VERSION FOCUSSES MORE SO ON THE CONTENTS PERTAINING
// TOWARDS THE COURSEWORK - KEEPING MY ORIGINAL IMPLEMENTATION ADJACENT

// NESTED INCLUDES 

#include "coursework/tsp.h"

int TSP_BEST_DIST;
int TSP_BEST_PATH[TSP_MAX_CITIES + 1];

const char* TSP_ERR_MSG[] =
{
    "OK",
    "INDEX OUT OF BOUNDS",
    "MAX CITIES EXCEEDED",
    "MAX DISTANCE EXCEEDED",
    "MAX VALUE FOR PATHING"
};

// INITIALISE THE ENCOMPASSING BASE FOR THE CURRENT TSP PROBLEM
// THE FOLLIWING WILL LOOK TO DETERMINE THE CITY COUNT, DISTANCES BETWEEN
// CITIES, ETC
//
// ENCORPERATES MATRIX ADDITION TO BE ABLE TO DETERMINE THE BASE
// DISTANCE BETWEEN CITIES
//
// BETWEEN THIS AND MY ORIGINAL TSP IMPLEMENTATION
// IT REMAINS MOSTLY THE SAME BARRING THE FACT THAT 
// THIS INCLUDES LOCAL SEARCH
int TSP_INIT(TSP_STATE* STATE)
{
    if(STATE == NULL) { TSP_MEM_ERROR(STATE); }

    STATE->CITY_COUNT = 0;
    STATE->DIST.SIZE = 0;
    STATE->TOUR.TSP_TOTAL_DIST = 0;
    STATE->TOUR.TSP_CITY_COUNT = 0;
    STATE->ALGO = TSP_TWO_OPT;

    // INITIALISE THE BASIS FOR THE ALGORITHMS BEING USED
    // THIS WILL BE UPDATED TO COMPARE AGAINST OTHER ALGORITHMS WHEN APPROPRIATE
    strcpy(STATE->STAT_DATA.ALGORITHM_A.NAME, TSP_ALGO_TYPE(STATE->ALGO));

    // NOW ITERATE THROUGH EACH OF THE MAX CITIES IN ACCORDANCE
    // WITH THE DISTANCE MATRIX BETWEEN THEM 
    for(int INDEX = 0; INDEX < TSP_MAX_CITIES; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < TSP_MAX_CITIES; ITERATOR++)
        {
            // HAVE WE REACHED THE MAX AMOUNT OF ITERATIONS?
            // THIS WAY, WE CAN DO A SAFER CHECK
            if(!TSP_VALID_CITY(INDEX, TSP_MAX_CITIES) || 
                !TSP_VALID_CITY(ITERATOR, TSP_MAX_CITIES))
            {
                goto TSP_OOB;
            }

            // ASSIGN THE CORRESPONDING VALUES TO EACH INDEX
            STATE->DIST.MATRIX[INDEX][ITERATOR] = (INDEX == ITERATOR) ? 0 : INT_MAX;
        }
    }

    TSP_HANDLE(NONE, TSP_ERROR_NONE, "\nTSP PARAMS:\n ALGORITHM: %s\n", TSP_ALGO_TYPE(STATE->ALGO));
    return 0;

    TSP_OOB:
        TSP_ERROR_HANDLE(OOB, TSP_ERROR_OOB, "MAX CITY VALUE: %d", TSP_MAX_CITIES);
        return 1;
}

// ADD A CITY TO THE CURRENT ALGORITHM TYPE
int TSP_ADD_CITY(TSP_STATE* STATE, const char* NAME, int X, int Y)
{
    // CHECK IF WE AHVE EXCEEDED THE AMOUNT OF CITIES DISCLOSED
    if(STATE->CITY_COUNT >= TSP_MAX_CITIES) goto TSP_CITY_MAX;

    // STORE AN INDEX OF THE CREATED CITY
    int CITY_INDEX = STATE->CITY_COUNT;

    // CREATE A NEW REPRESENTATION OF A CITY WITH IT'S RESPECTIVE
    // PARAMETERS AND INDEX IT TO THE CITY COUNT
    TSP_CITY* NEW_CITY = &STATE->CITY[STATE->CITY_COUNT];

    TSP_CITY_MAX:
        TSP_ERROR_HANDLE(CITY, TSP_ERROR_CITY, "MAX CITY COUNT: %d - CANNOT INDEX CITY: %s AT INDEX: %d", TSP_MAX_CITIES, NAME, CITY_INDEX);

    return 0;
}
