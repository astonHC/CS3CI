// COPYRIGHT (C) HARRY CLARK 2025
// CS3_CI TRAVELLING SALESMAN PROBLEM 

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF AREAS ENCOMPASSING THE TSP
// AS PER MODULE AND LAB CONTENTS OF CS3_CI

// SPECIFICALLY, THIS VERSION FOCUSSES MORE SO ON THE CONTENTS PERTAINING
// TOWARDS THE COURSEWORK - KEEPING MY ORIGINAL IMPLEMENTATION ADJACENT

// NESTED INCLUDES 

#include "tsp.h"

// INITIALISE THE ENCOMPASSING BASE FOR THE CURRENT TSP PROBLEM
// THE FOLLIWING WILL LOOK TO DETERMINE THE CITY COUNT, DISTANCES BETWEEN
// CITIES, ETC
//
// ENCORPERATES MATRIX ADDITION TO BE ABLE TO DETERMINE THE BASE
// DISTANCE BETWEEN CITIES
//
// BETWEEN THIS AND MY ORIGINAL TSP IMPLEMENTATION
// IT REMAINS MOSTLY THE SAME BARRING THE FACT THAT 
// THIS INCLUDES LOCAL SEARCH
int TSP_INIT(TSP_STATE* STATE, TSP_ALGO ALGO)
{
    if(STATE == NULL) { TSP_MEM_ERROR(STATE); }

    STATE->CITY_COUNT = 0;
    STATE->DIST.SIZE = 0;
    STATE->TOUR.TSP_TOTAL_DIST = 0;
    STATE->TOUR.TSP_CITY_COUNT = 0;
    STATE->ALGO = ALGO; 

    // NOW ITERATE THROUGH EACH OF THE MAX CITIES IN ACCORDANCE
    // WITH THE DISTANCE MATRIX BETWEEN THEM 
    for(int INDEX = 0; INDEX < TSP_MAX_CITIES; INDEX++)
    {
        for(int ITERATOR = 0; ITERATOR < TSP_MAX_CITIES; ITERATOR++)
        {
            // HAVE WE REACHED THE MAX AMOUNT OF ITERATIONS?
            // THIS WAY, WE CAN DO A SAFER CHECK
            if(!TSP_VALID_CITY(INDEX, TSP_MAX_CITIES) || 
                !TSP_VALID_CITY(ITERATOR, TSP_MAX_CITIES)) goto TSP_OOB; 

            // ASSIGN THE CORRESPONDING VALUES TO EACH INDEX
            STATE->DIST.MATRIX[INDEX][ITERATOR] = (INDEX == ITERATOR) ? 0 : INT_MAX;
        }
    }

    TSP_HANDLE(NONE, TSP_ERROR_NONE, "\nTSP PARAMS:\n ALGORITHM: %s\n", TSP_ALGO_TYPE(STATE->ALGO));
    return 0;

    TSP_OOB:
        TSP_ERROR_HANDLE(OOB, TSP_ERROR_OOB, "MAX CITY VALUE: %d", TSP_MAX_CITIES);
        return 1;
}

// ADD A CITY TO THE CURRENT ALGORITHM TYPE
int TSP_ADD_CITY(TSP_STATE* STATE, const char* NAME, double X, double Y)
{
    // CHECK IF WE AHVE EXCEEDED THE AMOUNT OF CITIES DISCLOSED
    if(STATE->CITY_COUNT >= TSP_MAX_CITIES) goto TSP_CITY_MAX;

    // STORE AN INDEX OF THE CREATED CITY
    int CITY_INDEX = STATE->CITY_COUNT;

    // CREATE A NEW REPRESENTATION OF A CITY WITH IT'S RESPECTIVE
    // PARAMETERS AND INDEX IT TO THE CITY COUNT
    TSP_CITY* NEW_CITY = &STATE->CITY[STATE->CITY_COUNT];

    // COPY THAT NEW CITY INTO THE BUFFER 
    // ACCOUNT FOR OFFSETTING TO PREVENT SPILLOVERS
    strncpy(NEW_CITY->NAME, NAME, sizeof(NEW_CITY->NAME)- 1);

    // MAP THE COORDINATE PARAMS OF THE CITY
    NEW_CITY->X = X;
    NEW_CITY->Y = Y;

    // PRINT OUT THE CORRESPONDENCE AND INCREMENT COUNT
    TSP_CITY_NAME(NAME, STATE->CITY_COUNT, X, Y);

    STATE->CITY_COUNT++;
    return 0;

    TSP_CITY_MAX:
        TSP_ERROR_HANDLE(CITY, TSP_ERROR_CITY, 
            "MAX CITY COUNT: %d - CANNOT INDEX CITY: %s AT INDEX: %d", 
            TSP_MAX_CITIES, NAME, CITY_INDEX);

        return 1;
}

// TIME FOR THE ALGORITHM TYPES
// THE FOLLOWING WILL LOOK TO SOLVE FOR NEAREEST NEIGHBOUR

// WHICH LOOKS TO FIND THE MOST SIMILAR LIKENESS WITHIN A STRUCTURE
// IN THIS CASE, IT WILL LOOK FOR LIKEWISE PATTERNS TO APPROXIMATELY
// DETERMINE SPACING
int TSP_NEAREST(TSP_STATE* STATE) 
{
    int VISITED[TSP_MAX_CITIES] = {0};
    int CURRENT_CITY = 0;
    int BASE_DIST = 0;
    int PATHING = 0;

    // DYNAMICALLY CALC THE DISTANCE RATHER 
    // THAN BEING A SEPERATE CALL 
    TSP_CALC_DIST(STATE);
    
    TSP_HANDLE(NONE, TSP_ERROR_NONE, "NEAREST NEIGHBOUR STARTING FROM: %s", 
        STATE->CITY[CURRENT_CITY].NAME);

    // FIRST DETERMINE THE CURRENT PATHING FROM THE CURRENT CITY
    // THEN CONFIRM WE HAVE VISITED
    STATE->TOUR.TSP_PATH[PATHING++] = CURRENT_CITY;
    VISITED[CURRENT_CITY] = 1;

    for(int STEP = 1; STEP < STATE->CITY_COUNT; STEP++)
    {
        int NEAREST = -1;           // THE NEAREST WILL ALWAYS BE THE ONE INDEXXED CLOSER
        int NEAR_DIST = INT_MAX;    // WE WILL NEVER REACH INF

        // DETERMINE HOW MANY STEPS HAVE BEEN TAKEN IN
        // ACCORDANCE WITH THE DISTANCE TRAVELLED
        TSP_HANDLE(NONE, TSP_ERROR_NONE, "STEP %d: SEARCHING FROM: %s", STEP, STATE->CITY[CURRENT_CITY].NAME);

        // INDEX THROUGH ALL OF THE CITIES
        // DETERMINE IF WE HAVENT VISITED AND IF IT CLOSER THAN THE NEAREST
        for(int INDEX = 0; INDEX < STATE->CITY_COUNT; INDEX++)
        {
            // VALIDATE AN EDGE CASE FOR SAFELY RETRIEVING VISIT
            int EDGE_DIST = STATE->DIST.MATRIX[CURRENT_CITY][INDEX];

            // THEN ADD THE INDEX TO THE "NOW CURRENT" NEAREST CITY
            // DO SO BY LEVERAGING THE SAFER PRE-PROC CHECK
            if(!VISITED[INDEX] && TSP_VALID_DIST(EDGE_DIST) && EDGE_DIST < NEAR_DIST)
            {
                NEAR_DIST = EDGE_DIST;
                NEAREST = INDEX;
            }
        }

        TSP_HANDLE(NONE, TSP_ERROR_NONE, "NEAREST CITY: %s WITH DISTANCE: %d", STATE->CITY[NEAREST].NAME, NEAR_DIST);

        // NOW AFTER DETERMINING THE INDEX AGAINST THE NEAREST DISTANCE
        // WE CAN MAP THAT WE HAVE VISITED
        VISITED[NEAREST] = 1;
        STATE->TOUR.TSP_PATH[PATHING++] = NEAREST;          // ADD THE NEAREST AND ADVANCE
        BASE_DIST += NEAR_DIST;                             // ADD THE DISTANCE TO THE TOTAL
        CURRENT_CITY = NEAREST;                             // UPDATE TO THE CURRENT CITY
    }

    // NOW MAP THE DISTANCE COVERED TO THE MATRIX 
    int RETURN_DIST = STATE->DIST.MATRIX[CURRENT_CITY][0];
    BASE_DIST += RETURN_DIST;

    TSP_HANDLE(NONE, TSP_ERROR_NONE, "RETURN TRIP: %s TO %s WITH DISTANCE: %d\n", 
    STATE->CITY[CURRENT_CITY].NAME, STATE->CITY[0].NAME, RETURN_DIST);

    // STORE ALL OF THE FINAL PARAMS USED ON THE TOUR
    STATE->TOUR.TSP_PATH[PATHING] = 0;
    STATE->TOUR.TSP_TOTAL_DIST = BASE_DIST;
    STATE->TOUR.TSP_CITY_COUNT = STATE->CITY_COUNT;

    TSP_HANDLE(DIST, TSP_ERROR_NONE, "DISTANCE COVERED %d\n", STATE->TOUR.TSP_TOTAL_DIST);

    return 0;
}
